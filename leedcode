1.                  class Solution {
                    public:
                        vector<int> twoSum(vector<int>& nums, int target) {
                            int n=nums.size();
                            int i,j;
                            for(i=0;i<n;i++)
                            {
                                for(j=i+1;j<n;j++)
                                {
                                    if(nums[i]+nums[j]==target)
                                    return {i,j};
                                }
                            }
                            return {};
                        }
                    };




2.                  class Solution {
                    public:
                        vector<int> twoSum(vector<int>& nums, int target) {
                            int n = nums.size();
                            for (int i = 0; i < n; ++i) {
                                for (int j = i + 1; j < n; ++j) {
                                    if (nums[i] + nums[j] == target) {
                                        return {i, j};
                                    }
                                }
                            }
                            return {};
                        }
                    };                                                                    //!!!竟然还是这道题






3.                  class Solution {
                    public:
                        int pivotIndex(vector<int>& nums) {
                            int s1=0,s2=0,i,n;
                            n=nums.size();
                            for(i=0;i<n;i++)        //从0开始对每一个a[i]判断是否符合索引条件
                            {
                                if(i==0)
                                {
                                    for(int c=1;c<n;c++)
                                    {
                                        s2+=nums[c];    //求和判断后续数字是否为0
                                    }
                                    if(s2==0)
                                    {
                                        cout<<0;
                                        return 0;        //直接结束程序,否则进行后续判断
                                    }
                                    s2=0;
                                }
                                else
                                {
                                    for(int a=0;a<i;a++) //统计左边
                                    {
                                        s1+=nums[a];
                                    }
                                    for(int b=i+1;b<n;b++) //统计右边
                                    {
                                        s2+=nums[b];
                                    }
                                    if(s1==s2)             //直接输出最左侧的索引，结束程序
                                    {
                                        cout<<i;
                                        return 0;
                                    }
                                    s1=0,s2=0;             //初始化
                                }
                            }
                            cout<<-1;                      //如果都不满足就输出-1
                            return 0;
                        }
                    };






4.                  class Solution {
                    public:
                        int pivotIndex(vector<int>& nums) {
                        int s1=0,s2=0,n=nums.size();
                        for(int a=1;a<n;a++)
                        s2+=nums[a];
                        for(int i=0;i<n;i++)
                        {
                            if(s1==s2)
                            return i;
                            s1+=nums[i];
                            s2-=nums[i+1];
                        }
                        return -1;
                        }
                    };
                    




5.                  class Solution {
                    public:
                        int searchInsert(vector<int>& nums, int target) {
                            int i,n=nums.size();
                            for(i=0;i<n;i++)                   //查找是否存在相同值
                            {
                                if(target==nums[i])
                                return i;
                            }
                            for(i=0;i<n;i++)                   //此时为不存在的情况，开始插入
                            {
                                if(target<nums[i])
                                return i;
                            }
                            return n;                           //插入到数组末尾的情况
                        }
                    };
                    
                    
                    
                    
                    
                    
                    
                    
                    
6.                  class Solution {
                    public:
                        void rotate(vector<vector<int>>& matrix) {
                            int n=matrix.size();           //矩阵为n*n
                            auto a=matrix;
                            for(int i=0;i<n;i++)           
                            {
                                for(int j=0;j<n;j++)    //旋转
                                {
                                   a[j][n-i-1]=matrix[i][j];   //将旋转后的结果存到a数组
                                }
                            }
                            matrix=a;
                        }
                    };





7.                  class Solution {
                    public:
                        void setZeroes(vector<vector<int>>& matrix) {
                            int n=matrix.size(),m=matrix[0].size();              //n表示行数,m表示列数
                            auto matrix_new=matrix;
                            for(int i=0;i<n;i++)
                            {
                                for(int j=0;j<m;j++)
                                {
                                    if(matrix[i][j]==0)          //对new执行清零操作
                                    {
                                        for(int k=0;k<n;k++)
                                        {
                                            matrix_new[k][j]=0;
                                        }
                                        for(int k=0;k<m;k++)
                                        {
                                            matrix_new[i][k]=0;
                                        }
                                    }
                                }
                            }
                            matrix=matrix_new;
                        }
                    };



8.                  class Solution {
                    public:
                        bool containsDuplicate(vector<int>& nums) {
                            sort(nums.begin(),nums.end());                               //排序 sort(n.begin(),n.end());
                            for(int i=0;i<nums.size()-1;i++)                             //判断数组长度的函数  n.size()
                            {
                                if(nums[i]==nums[i+1])
                                    return true;
                            }
                            return false;
                        }
                    };
                    
                    
                    
                    
                    
                    
9.                  class Solution {
                    public:
                        int maxSubArray(vector<int>& nums) {
                            int n=nums.size();
                            int Max=INT_MIN;                             //这个式子代表一个神奇的极小数(-2147483648)
                            for(int i=0;i<n;i++)
                            {
                                int sum=0;                               //对每一个nums[i]开头的连续子数组求最大和
                                for(int j=i;j<n;j++)
                                {
                                    sum+=nums[j];
                                    if(sum>Max)
                                    {
                                        Max=sum;
                                    }
                                }
                            }
                            return Max;
                        }
                    };





10.                 /**
                     * Definition for a binary tree node.
                     * struct TreeNode {
                     *     int val;
                     *     TreeNode *left;
                     *     TreeNode *right;
                     *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
                     *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
                     *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
                     * };
                     */
                    class Solution {
                    public:
                       void order(TreeNode *root, vector<int> &res)
                        {
                            if (!root)
                                return;
                            order(root->left, res);
                            res.push_back(root->val);
                            order(root->right, res);
                        }
                        vector<int> inorderTraversal(TreeNode *root)
                        {
                            vector<int> res;
                            order(root, res);
                            return res;
                        }
                    };






11.                 class Solution {
                    public:
                        vector<int> inorderTraversal(TreeNode* root) {
                            vector<int> ans;
                            stack<TreeNode*> S;
                            while (root|| !S.empty())                  //如果最下面的root->right为空,则对栈顶继续进行操作(栈顶root2对应的为root1的中结点)
                            {
                                while (root)
                                {
                                    S.push(root);                      //不断把左子树push入栈,直到左侧无子树(此时root->left==NULL)
                                    root = root->left;
                                }
                                root = S.top();                        //此处root为最左侧子树
                                S.pop();                               //将root弹出
                                ans.push_back(root->val);              //将root存入数据
                                root = root->right;                    //开始判断root->right(可能有值也可能为NULL)
                            }
                            return ans;
                        }
                    };





12.                 class Solution {
                    public:
                        vector<int> inorderTraversal(TreeNode* root) {
                            vector<int> ans;
                            stack<TreeNode*> S;
                            while (root|| !S.empty())                  //如果最下面的root->right为空,则对栈顶继续进行操作(栈顶root2对应的为root1的中结点)
                            {
                                while (root)
                                {
                                    S.push(root);                      //不断把左子树push入栈,直到左侧无子树(此时root->left==NULL)
                                    root = root->left;
                                }
                                root = S.top();                        //此处root为最左侧子树
                                S.pop();                               //将root弹出
                                ans.push_back(root->val);              //将root存入数据
                                root = root->right;                    //开始判断root->right(可能有值也可能为NULL)
                            }
                            return ans;
                        }
                    };





13.                 
