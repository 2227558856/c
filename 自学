1.                  #include <iostream>
                    using namespace std;
                    int main()
                    {
                      float a,b;
                      char op;
                      cout<<"请输入算式：（数1 运算符 数2）"<<'\n';
                      cin>>a>>op>>b;
                      if (op=='+')
                      cout<<a<<op<<b<<"="<<a+b;
                      else if(op=='-')
                      cout<<a<<op<<b<<"="<<a-b;
                      else if(op=='*')
                      cout<<a<<op<<b<<"="<<a*b;
                      else if(op=='/')
                      {if (b)
                      cout<<a<<op<<b<<"=" <<a/b;
                      else 
                      cout<<"错误，除数为0";
                      }
                      else
                      cout<<op<<"无效字符"; 
                      return 0;
		      
                     } 
                     
                     
                     
                     
                     
2.                    #include <iostream>
                      using namespace std;
                      int main()
                      {
                        int s=0,i=1;
                        while (i<=100)
                        {
                          s=s+i;
                          i=i+1;
                        }
                        cout<<"s="<<s;
                        return 0;
                      }  
                      
                      
                      
3.                    #include <iostream>
                      using namespace std;
                      int main()
                      {
                        float i=1.0,s=0,t;
                        while (i<100)
                        {
                          t=1.0/i;
                          s=s+t;
                          i=i+2;
                        }
                        cout<<"s="<<s;
                        return 0;
                      }      
                      
                      
                      
                      
4.                    #include <iostream>
                      #include <cmath>
                      using namespace std;
                      int main()
                      {
                        int i=1,b=1;
                        float s=0,t=1;
                        while (fabs(t)>1e-6)
                        {
                          t=b*1.0/i;
                          s=s+t;
                          i=i+2;
                          b=-b;
                        }
                        cout<<s*4;
                        return 0;
                       }   
                       
                       
                       
                       
                       
                       
5.                    #include <iostream>
                      using namespace std;
                      int main()
                      {
                        int i=1,s=0;
                        do
                        {
                          s=s+i;
                          i=i+1;
                        }while (i<=100);
                        cout<<s;
                        return 0;
                      }    
                      
                      
                      
                      
6.                      #include <iostream>
                        #include <cmath>
                        using namespace std;
                        int main()
                        {
                          float x1,x2,a;
                          cout<<"请输入："; 
                          cin>>a;
                          if (a<0)
                          cout<<"负数，无法开方";
                          else
                          {
                            x1=a/2;
                            do{
                              x2=x1;
                              x1=(x2+a/x2)/2;
                            }while (fabs(x1-x2)>1e-5);
                            cout<<"该数的平方根为；"<<x1;
                          }
                          return 0;
                         }        
                         
                         
                         
                         
             
7.                        #include <iostream>
                          using namespace std;
                          int main()
                          {
                            int a,b,c;
                            for (a=1;a<=4;a=a+1)
                            {
                              for (b=1;b<=4-a;b=b+1)
                              cout<<' ';
                              for (c=1;c<=2*a-1;c=c+1)
                              cout<<'*';
                              cout<<'\n';
                            }
                            for (a=1;a<=3;a++)
                            {
                              for (b=1;b<=a;b++)
                              cout<<' ';
                              for (c=1;c<=2*(3-a)+1;c++)
                              cout<<'*';
                              cout<<'\n';
                            }

                            return 0;
                          }
                          
                   


8.(不能求最小公倍数）       #include <iostream>
                          using namespace std;
                          int main()
                          {
                            float a,b,c,s;
                            int a1,b1,c1;
                            cout<<"请输入三个数：";
                            cin>>a>>b>>c;
                            for (s=a;s<a*b*c;s=s+1)
                            {
                            a1=s/a;
                            b1=s/b;
                            c1=s/c;	
                            if ((s-a*a1==0)&&(s-b*b1==0)&&(s-c*c1==0))
                            break;
                            }
                            cout<<a<<','<<b<<','<<c<<"的最小公倍数为"<<s;
                            return 0;
                          }
                          
                          
                          
                          
                          
                          
9.                        #include <iostream>
                          using namespace std;
                          int main()
                          {
                            int a,i;
                            cout<<"请输入：";
                            cin>>a;
                            for (i=2;i<a;i++)
                              if(a%i==0)
                              break;
                            if (i>=a)
                            cout<<"为素数";
                            else 
                            cout<<"非素数";
                            return 0;	
                          }                          




10.                         #include <iostream>
                            using namespace std;
                            int main()
                            {	int a;
                              for (a=1;a<=100;a++){
                              if (a%3==0)
                              continue;
                              cout<<a<<'\t';
                              }
                              return 0;
                             } 




11.              #include <iostream>
                using namespace std;
                #define PI 3.1415926535 
                int main()
                {	double s;
                  double r;
                  cin>>r;
                  s=PI*r*r;
                  cout<<"面积="<<s;
                  return 0; 
                 } 

12.                #include<iostream>
                  using namespace std;
                  int main()
                  {
                    int a;
                    float b;
                    cout<<"请输入变量a and b\n";
                    cin>>a>>b;
                    cout<<a<<'\t'<<b<<endl;
                    return 0;
                  }
13.对着课本硬抄下来的计算器             
                  #include<iostream>
                  using namespace std;
                  double cal(int a,char ch,int b)
                  {
                    double result;
                    if(a==0)
                      throw'x';
                    switch(ch)
                    {
                    case'+':
                      result=a+b;
                      break;
                    case'-':
                      result=a-b;
                      break;
                    case'*':
                      result=a*b;
                      break;
                    case'/':
                      if(b==0)
                        throw 0;
                      result=(double)a/b;
                      break;
                    default:
                      throw "输入错误，请重新输入！\n";
                    }
                    return result;
                  }
                  int main()
                  {
                    int a,b;
                    char ch;
                    while(1)
                    {
                      try
                      {
                        cout<<"请输入算式：";
                        cin>>a>>ch>>b;
                        cout<<a<<ch<<b<<"="<<cal(a,ch,b)<<endl;
                      }
                      catch(int)
                      {
                        cout<<"除数为0！\n";
                      }
                      catch(char*s)
                      {   cout<<s;
                      }
                      catch(...)
                      {   cout<<"谢谢使用！\n";
                        exit(0);
                      }
                    }
                    return 0;
                  }



14.                  #include <iostream>
                    using namespace std；
                    int main()
                    {
                      int i=1,s=0;
                      loop:if(i<=100){
                        s=s+i;
                        i++;
                        goto loop;}
                        cout<<"s="<<s; 
                        return 0;
                     } 




15.                    #include <iostream>
                      using namespace std;
                      int main()
                      {
                        double e=1.0,i=1.0;
                        int n=1;
                        while (i>=1e-7)
                        {
                          i=i/n;
                          e=e+i;
                          n++;
                        }
                        cout<<e;
                        return 0;
                      }




16.                      #include <iostream>
                        using namespace std;
                        int main()
                        {
                          double e=1,i=1;
                          int n=1;
                          do
                          {
                            i=i/n;
                            e=e+i;
                            n++;
                          }while (i>=1e-7);
                          cout<<e;
                          return 0;
                        }




17.                      #include <iostream>
                        #include <cstdlib>
                        #include <ctime>
                        using namespace std;
                        int main()
                        {
                          int a,b,op,sum=0;
                          int i,c,d;
                          srand(time(NULL));
                          for (i=1;i<=10;i++)
                          {
                            a=rand()%10;
                            b=rand()%10;
                            op=rand()%3;
                          switch (op)
                          {
                            case 0:cout<<a<<"+"<<b<<"=";
                            c=a+b;break;
                            case 1:cout<<a<<"-"<<b<<"=";
                            c=a-b;break;
                            case 2:cout<<a<<"*"<<b<<"=";
                            c=a*b;break;
                          }
                          cin>>d;
                          if (d==c){
                          cout<<"\n正确！\n";
                          sum=sum+10;}
                          else
                          cout<<"\n错误！\n";
                          }
                          cout<<"答对："<<sum/10<<"题"<<'\n'<<"得分："<<sum;
                          return 0;
                        }





18.                              #include <iostream>
                                using namespace std;
                                int max(int a,int b)
                                {
                                  int c;
                                  c=a>b?a:b;
                                  return c;
                                 } 
                                int main ()
                                {
                                  int x,y,z;
                                  cout<<"请输入：";
                                  cin>>x>>y;
                                  z=max(x,y);
                                  cout<<"较大的数："<<z;
                                  return 0; 
                                }






19.                                #include <iostream>
                                  using namespace std;
                                  void message()
                                  {
                                    cout<<"1.注册\n";
                                    cout<<"2.登录\n";
                                    cout<<"3.取消\n";
                                    cout<<"请输入选择\n";
                                  }
                                  int main()
                                  {
                                    int ch;              //这里用int定义的就是数字，如果用char，定义的就是字符
                                    message ();
                                    cin>>ch;
                                    cout<<"您输入的是："<<ch<<'\n'<<"即将为您执行：";
                                    switch (ch)
                                    {
                                      case 1:cout<<"注册";break;          //如果上面写的是char,这里就应该写case '1',即字符
                                      case 2:cout<<"登录";break;
                                      case 3:cout<<"取消";break; 
                                      default :cout<<"输入错误";break;
                                     } 
                                     return 0;
                                  }
                                  
                                  
                                  
                                  
                                  
                                  
20.  (错误）                      #include <iostream>                                             
				using namespace std;
				float fact(int m)
				{
					int x=1;
					cin>>m;           //错误所在，不能在fact函数里面输入，不然后面的循环会一直执行要求输入数字的操作，无法得到正确结果
					if(m<0)
					cout<<"输入无效！";
					else if(m>=0){
					while (m>=1){
					x=x*m;
					m--; }
					return x;			}
				}
				int main()
				{
					int n,s=0,i=1;
					cout<<"请输入：";
					cin>>n;
					while (i<=n){
					s=s+fact(i);
					i++;}
					cout<<s;
					return 0;
				}
				
				
				
				
				
				
				
21.（半对）                       #include <iostream>
				using namespace std;
				float fact(int m)
				{
					int x=1;
					if(m<0)
					cout<<"输入无效！";
					else if(m>=0){
					while (m>=1){
					x=x*m;
					m--; }
					return x;			}
				}
				int main()
				{
					int n,s=0,i=1;
					cout<<"请输入：";
					cin>>n;
					for (i=1;i<=n;i++)
					s=s+fact(i);
					cout<<s;
					return 0;
				}				



22. （正确）                      #include <iostream>
				using namespace std;
				float fact(int m)
				{
					int x=1;
					if(m>=0){
					while (m>=1){
					x=x*m;
					m--; }
					return x;			}
				}
				int main()
				{
					int n,s=0,i=1;
					cout<<"请输入：";
					cin>>n;
					if (n>=0){
					while (i<=n){
					s=s+fact(i);
					i++;}
					cout<<s;}
					else
					cout<<"输入无效！";
					return 0;
				}









23. （错误）                      #include <iostream>
				using namespace std;
				int l(int a,int b,int c)
				{
					int i;
					for (i=a;i>=1;i--)
					{
						if (a%i==0&&b%i==0&&c%i==0)
						break;
						return i;
					}
				}
				int main()
				{
					int x,y,z,t;
					cout<<"请输入：";
					cin>>x>>y>>z;
					t=l(x,y,z);
					cout<<x<<','<<y<<','<<z<<"的最大公倍数为："<<t;
					return 0;
				}



24. （正确）                      #include <iostream>
				using namespace std;
				int l(int a,int b,int c)
				{
					int i;
					for (i=a;i>=1;i--)
					{
						if (a%i==0&&b%i==0&&c%i==0)
						break;}                //这里大括号位置应该在return前面，不然return就会进入for循环，直接在后面输出
						return i;
				}
				int main()
				{
					int x,y,z,t;
					cout<<"请输入：";
					cin>>x>>y>>z;
					t=l(x,y,z);
					cout<<x<<','<<y<<','<<z<<"的最大公倍数为："<<t;
					return 0;
				}        







25.                                      #include <iostream>
					using namespace std;
					int swap(float& x,float& y)
					{
						float t;
						t=x;
						x=y;
						y=t;
					}
					int main()
					{
						float a,b;
						cout<<"交换前：a="<<'\t'<<"b="<<'\n';
						cin>>a>>b;
						swap(a,b);
						cout<<"交换后：a="<<a<<'\t'<<"b="<<b;
						return 0;
					}






26.                                      #include <iostream>
					using namespace std;
					int X(int m,int k)
					{
						int i,p=1;
						for(i=1;i<=k;i++)
						p=p*m;
						return p;
					}
					int Y(int n,int k)
					{
						int s=0;
						for(int i=1;i<=n;i++)
						s=s+X(i,k);
						return s;
					}
					int main()
					{
						int n,k,s;
						cout<<"请输入n,k的值；";
						cin>>n>>k;
						s=Y(n,k);
						cout<<"1^k+2^k+...+"<<n<<"^k="<<s;
						return 0; 
					}




27.                                     #include <iostream>
					using namespace std;
					int main()
					{
						int a=1,b=2;
						int *p1=&a,*p2=&b; 
						cout<<a<<'\t'<<b<<endl;
						cout<<p1<<'\t'<<p2<<endl;
						cout<<*p1<<'\t'<<*p2<<endl;
						return 0;
					}



28.                     #include <iostream>
			using namespace std;
			int main()
			{
				int a,b;
				cin>>a>>b;
				cout<<"a="<<a<<'\t'<<"b="<<b<<endl;
				int *p1=&a,*p2=&b,*p;
				if(a>b)
				{
					p=p1;
					p1=p2;
					p2=p;
				}
				cout<<"从小到大输出"<<'\n'<<*p1<<'\t'<<*p2<<endl;
				cout<<"a="<<a<<'\t'<<"b="<<b;
			}



29.                     #include <iostream>
			using namespace std;
			int main()
			{
				int a,b;
				cin>>a>>b;
				cout<<"a="<<a<<'\t'<<"b="<<b<<endl;
				int *p1=&a,*p2=&b,t;
				if(a>b)
				{
					t=*p1;
					*p1=*p2;
					*p2=t;
				}
				cout<<"从小到大输出"<<'\n'<<*p1<<'\t'<<*p2<<endl;
				cout<<"a="<<a<<'\t'<<"b="<<b;
			}




30.                     #include <iostream>
			using namespace std;
			int main()
			{
				int a[10]={1,2,3,4,5,6,7,8,9,10},t;
				int *p=a,*q;
				q=p+9;
				while (p<q)
				{
					t=*p;
					*p=*q;
					*q=t;
					p++;
					q--;
				}
				for (int i=0;i<10;i++)
				cout<<a[i]<<'\t'; 
				return 0;
			}



31.                     #include <iostream>
			using namespace std;
			int main()
			{
				int a[10]={1,2,3,4,5,6,7,8,9,10},t;
				int *p=a,*q;
				q=p+9;
				while (p<q)
				{
					t=*p;
					*p=*q;
					*q=t;
					p++;
					q--;
				}
				for (int i=0;i<10;i++)
				cout<<a[i]<<'\t'; 
				return 0;
			}



32.                     #include <iostream>
			using namespace std;
			int main()
			{
				char a[100]={"I like sleeping !"},*p2,*p1;
				p1=&a[0];                                //即将a[0]的位置传到p1，也可以写为：p1=a 
				p2="I like studying !";
				cout<<p1<<endl;
				cout<<p1+2<<endl;                          //从指针位置开始输出字符串 
				cout<<*p1<<endl;                          //表示只输出p1位置对应的字符(单个字符)
				cout<<*(p1+2)<<endl; 
				*p1='W';
				*(p1+1)='e';
				cout<<p1<<endl;
				cout<<*p2<<endl;                                //注意：p2为字符串常量，不可重新赋值
				cout<<*(p2+2)<<endl;
				cout<<p2+2;
				return 0; 
			 } 



33.             #include <iostream>
		using namespace std;
		int main()
		{
			int a[10]={1,2,3},b=1,*p1,*p2,*p3;
			p1=&a[0];
			p2=&b;
			p3=a;
			cout<<p1<<endl;
			cout<<*p1<<endl;
			cout<<p2<<endl;
			cout<<*p2<<endl;
			cout<<p3<<endl;
			cout<<*p3<<endl;                          //根据输出结果可以得知，以指针可以输出整个数组的方法只对字符数组有效 
			char c[10]={"123"},d='4',*p4,*p5,*p6;
			p4=&c[0];
			p5=&d;
			p6=c;
			cout<<p4<<endl;
			cout<<*p4<<endl;
			cout<<p5<<endl;
			cout<<*p5<<endl;
			cout<<p6<<endl;
			cout<<*p6<<endl;   
		}



34.             #include <iostream>
		using namespace std;
		int main()
		{
			char a[100]="I like sleeping!",b[100];
			char *p1=a,*p2=b;
			while(*p1)
			{
				*p2=*p1;
				p1++;
				p2++;
			}
			*p2='\0';
			cout<<b;
			cout<<*(p2-1);
			return 0;
		}




35.             #include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			int a=1; 
			int *const p=&a;             //常指针--无法再改变P指向的位置，即p=&b这样的形式是无法实现的
			const int *p=&a;             //即p是可以改变的，p=&b是正确的，但无法对p进行重新赋值，*p=2不合理 
			const int *const p=a;        //综合上述 
		}



36.             #include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			int n,*p;
			double s=0;
			cout<<"输入学生人数：";
			cin>>n;
			p=new int[n];
			for (int i=0;i<n;i++)
			{
				cout<<"请输入第"<<i+1<<"名学生的成绩：";
				cin>>p[i];
				s+=p[i]; 
			}
			cout<<"平均成绩："<<s/n;
			return 0;
		 } 




37.             #include <bits/stdc++.h>
		using namespace std;
		int change(int *p,int n)
		{
			int *q=p+n-1,t;
			while(q>p)
			{
				t=*p;
				*p=*q;
				*q=t;
				p++;
				q--;
			}
		}
		int main()
		{
			int *p,n,a[100];
			cout<<"输入数组个数：";
			cin>>n;
			cout<<"请输入数组：";
			for (int i=0;i<n;i++)
			{
				cin>>a[i];
			}
			p=&a[0];
			change(p,n);
			for (int i=0;i<n;i++)
			cout<<a[i]<<'\t';
			return 0;
		}



38.             #include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			char a[100];
			int n;
			int b=0,c=0,d=0,e=0,f=0;
			cout<<"输入字符个数：";
			cin>>n;
			cin.get();                                //用该式来接受上面输入的回车键，以免下面的getline误解
			cout<<"请输入一串字符：";                    
			cin.getline(a,n);                        //这里不知道为什么不能输入数据
			cout<<a;
			for (int i=0;i<n;i++)
			{
				if(a[i]>='A'&&a[i]<='Z')
				b++;
				else if(a[i]>='a'&&a[i]<='z')
				c++;
				else if(a[i]==' ')
				d++;
				else if(a[i]>='0'&&a[i]<='9')
				e++;
				else
				f++;
			}
			cout<<"大写字母："<<b<<endl;
			cout<<"小写字母："<<c<<endl;
			cout<<"空格："<<d<<endl;
			cout<<"数字："<<e<<endl;
			cout<<"其他字符："<<f<<endl;
			return 0; 
		}



39.             #include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			char a[100],*p;
			p=&a[0];
			int b=0,c=0,d=0,e=0,f=0;                          
			cout<<"请输入一串字符：";                    
			cin.getline(a,100);                        
			while(*p)
			{
				if(*p>='A'&&*p<='Z')
				b++;
				else if(*p>='a'&&*p<='z')
				c++;
				else if(*p==' ')
				d++;
				else if(*p>='0'&&*p<='9')
				e++;
				else
				f++;
				p++;
			}
			cout<<"大写字母："<<b<<endl;
			cout<<"小写字母："<<c<<endl;
			cout<<"空格："<<d<<endl;
			cout<<"数字："<<e<<endl;
			cout<<"其他字符："<<f<<endl;
			return 0; 
		}




40.             /*
		我国古代难题百鸡问题：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一。
		百钱买百鸡，问鸡翁、母、雏各几何？鸡翁数,鸡母数,鸡雏数等可以为零。
		结果保存到out.txt中，
		格式按照
		鸡翁数,鸡母数,鸡雏数顺序排列，中间用逗号隔开，有多组值的话，每组一行。
		(注意分隔符逗号，为英文逗号）
		比如：最后算出的鸡翁数,鸡母数,鸡雏数等为0，25，75。
		则out.txt
		0,25,75
		注意：完善现有代码，不要删除注释语句。 
		---------------------------------------------------------------------------------------------------*/
		/**********Begin**********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ofstream out;
			out.open("out.txt");
			for (int a=0;a<20;a++)
			{
				for (int b=0;b<40;b++)
				{
					for (int c=0;c<300;c++)
					if((a*5+b*3+c/3==100)&&(a+b+c==100)&&(c%3==0))
					out<<a<<","<<b<<","<<c<<endl;
				}
			out.close();
			return 0;
		}
			}





		/**********  End  **********/




41.             /* 求满足条件n!<m的最大数n。
		m为正整数，由in.txt读入, 
		将结果n输出到out.txt文件中。
		如:in.txt
		30
		则:out.txt
		4 
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/

			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ifstream in("in.txt");
			ofstream out;
			out.open("out.txt");
			int m,k=1,j=0;
			in>>m;
			for (int i=1;k*i<m;i++)
			{
				k=k*i;
				j++;
			}
			out<<j;
			in.close();
			out.close();
			return 0;
		 } 

			/**********   End  ***********/



42.             /* 
		给3个正整数a、b、c，判断是否是三角形的三条边。是的话，输出为Y,否的话，输出为N 
		三角形三条边满足条件：任意两边之和大于第三边，并且任意两边之差小于第三边。
		a,b,c从in.txt读取，结果输出到out.txt中 
		如:
		in.txt
		3 4 5
		则out.txt
		Y

		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/
			/**********  Begin  **********/
		#include <bits/stdc++.h> 
		using namespace std;
		int main()
		{
			ifstream in("in.txt");
			ofstream out;
			out.open("out.txt");
			int a[3];
			for (int i=0;i<3;i++)
			in>>a[i];
			sort(a,a+3);
			if(a[0]+a[1]>a[2])
			out<<"Y";
			else
			out<<"N";
			in.close();
			out.close();
			return 0; 
		}
			/**********   End  ***********/


43.             /* 在爱尔兰守神节那天，举行每年一度的庆祝游戏，
		指挥者若将乐队排成10人、9人、8人、7人、6人、5人、4人、3人和2人一排时，
		最后的一排总是缺少一个人，
		那些人想这个位置大概是给数月前死去的乐队成员凯西还留着位置。
		指挥者见到总缺一人恼火了，叫大家排成一列纵队前进。
		那么乐队究竟有多少人？(求出最小数)
		通过程序编程算出。(需要有循环结构)
		将结果输出到out.txt文件中。
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/

			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ofstream out;
			out.open("out.txt");
			int n=1;
			for (int i=1;;i++)
			{
				if((i%10==9)&&(i%9==8)&&(i%8==7)&&(i%7==6)&&(i%6==5)&&(i%5==4)&&(i%4==3)&&(i%3==2)&&(i%2==1))
				{
					out<<n;
					break;
				}
				n++;
			}
			out.close();
			return 0;
		}
			/**********   End  ***********/



44.              /* 从in.txt顺序读取所有的字符。把读取的顺序数字字符组成整数，输出到out.txt中。
		每个数字占一行
		格式如下：
		如:in.txt
		)yR[6.[L`56*LVRA<%S<xu>267eT]r>Y~S523]/H80\X"E12D1\)
		则out.txt
		6 
		56 
		267 
		523 
		80
		12 
		1
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/

			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ifstream in("in.txt");
			ofstream out;
			out.open("out.txt");
			string a;
			in>>a;
			for (int i=0;;i++)
			{
				if(a[i]>='0'&&a[i]<='9')
				{
					out<<a[i];
					if(a[i+1]!='0'&&a[i+1]!='1'&&a[i+1]!='2'&&a[i+1]!='3'&&a[i+1]!='4'&&a[i+1]!='5'&&a[i+1]!='6'&&a[i+1]!='7'&&a[i+1]!='8'&&a[i+1]!='9')
					out<<'\n';
				}
				if(a[i]=='\0')
				break;
			}
			in.close();
			out.close();
			return 0;
		}

			/**********   End  ***********/




45.              /* 
		从输入文件in.txt中读取所有的整数(整数个数大于2)，
		输出这些整数的平均值 .
		如:in.txt
		34 5 78 9 2 89 -8 -1903 3234 
		则:out.txt
		171.111
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/

			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			int a[1000],s=0,n=0;
			double m;
			ifstream in("in.txt");
			ofstream out;
			out.open("out.txt");
			for (int i=0;;i++)
			{
				in>>a[i];
				s+=a[i];
				n++;
				if(a[i]=='\0')
				break;
			}
			m=(double)s/n;
			out<<m;
			in.close();
			out.close();
			return 0;
		 } 
			/**********   End  ***********/




46.              /* 某女士手里拎了一篮鸡蛋，从她身边奔跑而过一匹惊马，
		吓了她一跳，结果把篮里的鸡蛋打翻了，
		她说两个一数，三个一数，四个一数，五个一数时，
		余数分别为1，2，3和4。
		问篮里原有多少个鸡蛋？(求出最小数)
		通过程序编程算出。
		将结果输出到out.txt文件中。
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/


			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ofstream out;
			out.open("out.txt");
			int k=0;
			for(int i=1;;i++)
			{
				k++;
				if((i%2==1)&&(i%3==2)&&(i%4==3)&&(i%5==4))
				{
					out<<k;
					break;
				}
			}
			out.close();
			return 0;
		 } 
			/**********   End  ***********/



47.               /* 求两个正整数m,n的最大公约数。
		两个正整数m,n从in.txt循环读入,直到全部读完， 
		并将结果输出到out.txt文件中。
		如:in.txt
		24 12
		34 67
		8 6
		5 89
		23 46
		则:out.txt
		12
		1
		2
		1
		23
		注意：请勿删除注释语句。 
		---------------------------------------------------------------------------------------------------*/

			/**********  Begin  **********/
		#include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			ifstream in("in.txt");
			ofstream out;
			out.open("out.txt");
			int a[100],b[100],t;
			for (int i=0;;i++)
			{
				in>>a[i]>>b[i];
				if(a[i]>b[i])
				{
					t=a[i];
					a[i]=b[i];
					b[i]=t;
				}
				t=a[i];
				for (int k=a[i];k>=1;k--)
				{
					if((a[i]%k==0)&&(b[i]%k==0))
					{
						out<<t<<endl;
						break;
					}
					t--;
				}
				if(a[i]=='\0')
				break;
			}
			in.close();
			out.close();
			return 0;
		 } 

			/**********   End  ***********/




48.              /*
		编写函数fun实现矩阵（3行3列）的转置（即行列互换）   
		例如：输入下面的矩阵： 
		       100 200 300     
		       400 500 600     
		       700 800 900 
		转置结果：   
		      100 400 700     
		      200 500 800
		      300 600 900     
		注意：请勿改动主函数main和其它函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <iostream>
		#include <fstream>
		using namespace std;          
		void  fun(int array[3][3])    
		{
		  /**********Begin**********/   
		  for (int i=2;i>=0;i--)     
		  {
		    for (int j=2;j>=0;j--)     
		    {
			array[i][j]=array[j][i];
			 } 
		  }     
		  /**********  End  **********/
		}     
		int main()     
		{   
		  void  xxx();   
		  int i,j;     
		  int array[3][3]={{100,200,300},{400,500,600},{700,800,900}};     
		  for (i=0; i < 3; i++)     
		  {
		    for (j=0; j < 3; j++)     
		      cout<<array[i][j]<<' ';     
		    cout<<'\n';     
		  }     
		  fun(array);     
		  cout<<"Converted array:"<<endl;     
		  for(i=0;i<3;i++)     
		  { 
		    for(j=0;j<3;j++)     
		      cout<<array[i][j]<<' ';     
		    cout<<'\n';
		  }
		  xxx();
		  return 0;     
		} 

		void xxx()     
		{       
		  ifstream IN("in.txt",ios::in);
		  ofstream OUT;
		  OUT.open("out.txt",ios::out);
		  int i,j, array[3][3]; 
		  for (i=0; i < 3; i++)     
		    for (j=0; j < 3; j++)     
		      IN>>array[i][j];     
		    fun(array);     
		    for (i=0; i < 3; i++)     
		    { 
		      for (j=0; j < 3; j++)     
			OUT<<array[i][j]<<' ';     
		      OUT<<'\n';     
		    }     
		  IN.close();
		  OUT.close();    
		}



49.             /*
		编写函数fun:实现字符串的复制，即将str1中的字符串复制到str2中。（不允许用字符串库函数strcpy）。
		注意：请勿改动主函数main和其它函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include<iostream>
		#include<fstream>
		using namespace std;
		void fun(char str1[],char str2[])
		{
		  /**********Begin**********/
		  for(int i=0;i<40;i++)
		  {
			str2[i]=str1[i];
			if(str1[i]=='\0')
			break;
		  }
		  /**********  End  **********/
		}
		int main()
		{
		  void xxx();
		  char c1[40],c2[40];
		  cout<<"请输入要复制的字符串：\n";
		  cin.getline(c1,40);
		  fun(c1,c2);
		  cout<<"复制的结果："<<c2;
		  xxx();
		 return 0;
		}

		void xxx()
		{
		     ifstream inf;
		     ofstream outf;
		     inf.open("in.txt",ios::in);
		     outf.open("out.txt",ios::out);
		     int i;
		     char s1[40],s2[40];
		     while(!inf.eof())
		     {
			inf.getline(s1,40);
			    fun(s1,s2);
			outf<<s2;	
		     }    
		     inf.close();
		     outf.close();

		}



50.              /*
		编写函数fun：将字符串中的大写字母转换为对应的小写字母，其它字符不变。
		例如，输入：
		   HELLO world!
		结果：
		   hello world!
		注意：请勿改动主函数main和其它函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <iostream>
		#include <fstream>
		using namespace std;
		void fun(char str[])
		{
		  /**********Begin**********/
		  for(int i=0;i<40;i++)
		  {
			if(str[i]>='A'&&str[i]<='Z')
			str[i]=str[i]+32;
			if(str[i]=='\0')
			break;
		  }
		  /**********  End  **********/
		}


		int main()
		{
		  void xxx();
		  char str[40];
		  cout<<"请输入字符串\n";
		  cin.getline(str,40);
		  fun(str);
		  cout<<"大写字母转换成小写字母的结果：\n"<<str;
		  xxx();
		  return 0;
		}

		void xxx()
		{
		  /* 本函数用于打开文件，输入测试数据，调用fun函数，输出数据，关闭文件。*/
		     ifstream inf;
		     ofstream outf;
		     inf.open("in.txt",ios::in);
		     outf.open("out.txt",ios::out);
		     char s1[40];
		     inf.getline(s1,40);
		     fun(s1);
		     outf<<s1;
		     inf.close();
		     outf.close();
		}




51.             #include <bits/stdc++.h>
		using namespace std;
		int main()
		{
			float s=0;
			struct student
			{
				char name[];
				int sorce[4];
				float aver;
			};
			student stu;
			cout<<"输入姓名：";
			cin>>stu.name;
			cout<<"各科分数:";
			for(int i=0;i<4;i++)
			{
				cin>>stu.sorce[i];
				s+=stu.sorce[i];
			}
			stu.aver=s/4;
			cout<<"平均分："<<stu.aver;
			return 0;
		 } 



52.                     #include <bits/stdc++.h>
			using namespace std;
			struct a
			{
				char name[20]; 
				int sorce;
				char sex;
			};
			a num[]={{"xiaohuang",110,'boy'},{"xiaoliu",120,'girl'},{"xiaowang",130,'girl'}};
			int main()
			{
				int n;
				a t;
				n=sizeof(num)/sizeof(num[0]);
				for (int i=0;i<n;i++)
				{
					if(num[i].name>num[i+1].name)
					{
						t=num[i];
						num[i]=num[i+1];
						num[i+1]=t;
					}
				}
				for(int i=0;i<n;i++)
				{
					cout<<"姓名：" <<num[i].name<<endl;
					cout<<"成绩：" <<num[i].sorce<<endl;
					cout<<"性别：" <<num[i].sex<<endl;
				}
				return 0;
			 } 




53.                     #include <bits/stdc++.h>
			using namespace std;
			struct student
			{
				char name[20];
				int id;
				float sorce[4];
			};
			int main()
			{
				float s=0,aver;
				student a,*p;
				p=&a;
				strcpy(a.name,"xiaozhang");
				a.id=2020211;
				cout<<"请输入四科成绩:";
				for (int i=0;i<4;i++)
				{
					cin>>p->sorce[i];
					s+=p->sorce[i];
				}
				cout<<"学生信息："<<endl;
				cout<<"姓名："<<p->name<<endl;
				cout<<"学号："<<p->id<<endl;
				cout<<"平均成绩："<<s/4;
				return 0;
			}





54.                     #include <iostream>
			using namespace std;
			struct code
			{
				int m;
				char n;
			};
			int main()
			{
				code a[]={{100,'A'},{200,'B'},{300,'C'}},*p;
				p=a;
				cout<<++p->m<<endl;                //100
				cout<<++(p++)->n<<endl;            //B
				cout<<++p->m<<endl;                //201
				cout<<(++p)->n++<<endl;            //C
				cout<<p->n<<endl;                  //D 
				cout<<p->m++;                      //300
				return 0;
			}




55.                     #include <bits/stdc++.h>
			using namespace std;
			class what
			{
				private:
					double a,b,c;
				public:
					void abc(double,double,double);
					double C(void);
					double S(void);
			};
			void what::abc(double x,double y,double z)
			{
				a=x;
				b=y;
				c=z;
			}
			double what::C(void)
			{
				return a+b+c;
			}
			double what::S(void)
			{
				double t=(a+b+c)/2;
				double s=sqrt(t*(t-a)*(t-b)*(t-c));
				return s;
			}
			int main()
			{
				what k,j;
				k.abc(3,4,5);
				j.abc(6,6,6);
				cout<<"周长1="<<k.C()<<'\t'<<"面积1="<<k.S()<<endl;
				cout<<"周长2="<<j.C()<<'\t'<<"面积2="<<j.S()<<endl;
				return 0;
			}




56。                     #include <bits/stdc++.h>
			using namespace std;
			class what
			{
				private:
					double a,b,c;
				public:
					void abc(double,double,double);
					double C(void);
					double S(void);
			};
			void what::abc(double x,double y,double z)
			{
				a=x;
				b=y;
				c=z;
			}
			double what::C(void)
			{
				return a+b+c;
			}
			double what::S(void)
			{
				double t=(a+b+c)/2;
				double s=sqrt(t*(t-a)*(t-b)*(t-c));
				return s;
			}
			int main()
			{
				what k,*p;
				p=&k;
				p->abc(6,6,6);
				cout<<p->C()<<'\t'<<p->S();
				return 0;
			}



57.		#include <bits/stdc++.h>
		using namespace std;
		class what
		{
			private:
				double a,b,c;
			public:
				void abc(double,double,double);
				double C(void);
				double S(void);
		};
		void what::abc(double x,double y,double z)
		{
			a=x;
			b=y;
			c=z;
		}
		double what::C(void)
		{
			return a+b+c;
		}
		double what::S(void)
		{
			double t=(a+b+c)/2;
			double s=sqrt(t*(t-a)*(t-b)*(t-c));
			return s;
		}
		int main()
		{
			what k;
			what &p=k;
			p.abc(6,6,6);
			cout<<p.C()<<'\t'<<p.S();
			return 0;
		}



58.		#include <bits/stdc++.h>
		using namespace std;
		class what
		{
			private:
				double a,b,c;
			public:
				void abc(double,double,double);
				void abc(double);
				double C(void);
				double S(void);
		 };
		void what::abc(double x,double y,double z)
		{
			a=x;
			b=y;
			c=z;
		}
		void what::abc(double x)
		{
			a=b=c=x;
		}
		double what::C(void)
		{
			return a+b+c;
		}
		double what::S(void)
		{
			double t=(a+b+c)/2;
			double s=sqrt(t*(t-a)*(t-b)*(t-c));
			return s;
		}
		int main()
		{
			what a,b;
			a.abc(3,4,5);
			b.abc(6);
			cout<<"周长1="<<a.C()<<'\t'<<"面积1="<<a.S()<<endl;
			cout<<"周长2="<<b.C()<<'\t'<<"面积2="<<b.S()<<endl;
			return 0;
		 } 



59.		#include <bits/stdc++.h>
		using namespace std;
		class what
		{
			private:
				double a,b,c;
			public:
				void abc(double x=5);
				double C(void);
				double S(void);
		};
		void what::abc(double x)
		{
			a=b=c=x;
		}
		double what::C(void)
		{
			return a+b+c;
		}
		double what::S(void)
		{
			double t=(a+b+c)/2;
			double s=sqrt(t*(t-a)*(t-b)*(t-c));
			return s;
		 } 
		int main()
		{
			what a,b;
			a.abc();
			b.abc(6);
			cout<<"周长1="<<a.C()<<'\t'<<"面积1="<<a.S()<<endl;
			cout<<"周长2="<<b.C()<<'\t'<<"面积2="<<b.S()<<endl;
			return 0;
		}



60.             #include <bits/stdc++.h>
		using namespace std;
		class num
		{
			private:
				int a,b;
			public:
				void xy(int x,int y);
				int A();                 //最大公约数 
				int B();                 //最小公倍数 
		};
		void num::xy(int x,int y)
		{
			a=x;
			b=y;
		}
		int num::A()
		{
			int m,n,t;
			m=a;
			n=b;
			if(m>n)
			{
				t=m;m=n;n=t;
			}
			while(t=n%m)
			{
				n=m;m=t;                  //欧几里得算法 
			}
			return m; 
		}
		int num::B()
		{
			int m=A();
			return a*b/m;                 //最小公倍数=两数相乘/最大公约数 
		}
		int main()
		{
			num N;
			int a,b;
			cout<<"请输入两个整数：";
			cin>>a>>b;
			N.xy(a,b);
			cout<<"最大公约数："<<N.A()<<endl;
			cout<<"最小公倍数："<<N.B();
			return 0; 
		}



61.            #include <bits/stdc++.h>
		using namespace std;
		class N
		{
			private:
			double a,b,c;
			public:
			void abc(double x,double y,double z);
			void fun();                        //使用fun函数直接输出结果 
		};
		void N::abc(double x,double y,double z)
		{
			a=x;b=y;c=z;
		}
		void N::fun()
		{
			double delta;
			delta=b*b-4*a*c;
			if(delta<0)
			cout<<"方程无实根！";
			else
			{
				delta=sqrt(delta);                             //delta开方 
				if(delta)                                     //delta不为0时，方程有不同实根
				{
					cout<<"方程有不同实根："<<(-b+delta)/2/a<<'\t'<<(-b-delta)/2/a;
				 }
				else
				{
					cout<<"方程有相同实根："<<-b/2/a;
				}
			}
		}
		int main()
		{
			N num;
			double a,b,c;
			cout<<"请输入三个系数：";
			cin>>a>>b>>c;
			num.abc(a,b,c);
			num.fun();
			return 0;
		}




62.             #include <bits/stdc++.h>
		using namespace std;
		class N
		{
			private:
				int n;
			public:
				void nn(int m);
				int NN(int x);
				int sum();
		};
		void N::nn(int m)
		{
			n=m;
		}
		int N::NN(int x)             //设置一个求阶乘的函数，其中X由sum函数输入 
		{
			int t=1;
			for(int i=1;i<=x;i++)
			t*=i;
			return t;
		}
		int N::sum()
		{
			int s=0;
			for(int i=1;i<=n;i++)
			s+=NN(i);
			return s;
		}
		int main()
		{
			N num;
			int n;
			cout<<"输入：";
			cin>>n;
			num.nn(n);
			cout<<"s="<<num.sum();
			return 0;
		}



63.             #include <bits/stdc++.h>
		using namespace std;
		class myclass
		{
			public:
				int num;
				void set(int i);
		};
		int num=3;
		void myclass::set(int i)
		{
			num=i;
		}
		int main()
		{
			myclass my1;
			int num=10;
			my1.set(5);
			cout<<my1.num<<endl;
			my1.set(num);
			cout<<my1.num<<endl;
			my1.set(::num);
			cout<<my1.num;
			return 0;
		}







64.              #include <bits/stdc++.h>
		using namespace std;
		class arr
		{
			int a[10],len;
			public:
				void setarr(int *p,int n=10)
				{
					len=n;
					for (int i=0;i<len;i++)
					a[i]=p[i];
				}
				int maxarr()
				{
					int max=a[0];
					for (int i=0;i<len;i++)
					if(max<a[i])
					max=a[i];
					return max;
				}
				int maxarr(int n)
				{
					int max=a[0];
					for (int i=0;i<n;i++)
					if(max<a[i])
					max=a[i];
					return max;
				}
				int maxarr(unsigned n)
				{
					return a[n];
				}
		};
		int main()
		{
			int a1[10]={1,2,3,4,5,6,7,8,9,10};
			int a2[5]={1,2,3,4,5};
			arr arr1,arr2;
			arr1.setarr(a1);
			arr2.setarr(a2,sizeof(a2)/sizeof(int));
			cout<<arr1.maxarr()<<endl;
			cout<<arr2.maxarr(3)<<endl;
			cout<<arr2.maxarr(3u)<<endl;
			return 0;
		}




65.              #include <bits/stdc++.h>
		using namespace std;
		class N
		{
			private:
				double a,b,c;
			public:
				N(double x,double y,double z)
				{
					a=x;b=y;c=z;
				}
				double C(void)
				{
					return a+b+c;
				}
				double S(void)
				{
					double t=(a+b+c)/2;
					double s=sqrt(t*(t-a)*(t-b)*(t-c));
					return s;
				}
		};
		int main()
		{
			N n(3,4,5);
			N m(6,6,6);
			return 0;
		}




66.            #include <bits/stdc++.h>
		using namespace std;
		class N
		{
			private:
				double a,b,c;
			public:
				N(double x,double y,double z)
				{
					a=x;b=y;c=z;
				}
				N(double x)
				{
					a=b=c=x;
				}
				double C(void)
				{
					return a+b+c;
				}
				double S(void)
				{
					double t=(a+b+c)/2;
					double s=sqrt(t*(t-a)*(t-b)*(t-c));
					return s;
				}
		};
		int main()
		{
			N n(3,4,5);
			N m(6);                                    //使用构造函数可以让创建对象时不用函数名，更加简便 
			return 0;
		}



67.            #include <bits/stdc++.h>
		using namespace std;
		class N
		{
			private:
				double a,b,c;
			public:
				N(double x,double y,double z)
				{
					a=x;b=y;c=z;
				}
				double C(void)
				{
					return a+b+c;
				}
				double S(void)
				{
					double t=(a+b+c)/2;
					double s=sqrt(t*(t-a)*(t-b)*(t-c));
					return s;
				}
				~N()
				{
					cout<<"析构函数";
				 } 
		};
		int main()
		{
			N n(3,4,5);
			N m(6,6,6);
			return 0;
		}





68.             /*编写函数fun实现将字符串按字符降序排列。
		如：in.txt
		CEAedcab
		则:out.txt
		edcbaECA
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句 
		---------------------------------------------------------------------------------------------------*/
		#include<fstream>
		#include<string.h>
		using namespace std;

		/**********Begin**********/
		void fun(char *s)
		{
			char *p=s,t;
			int n=strlen(s);
			for(int i=0;i<n-1;i++)
			{
				for(int j=0;j<n-i-1;j++)
				{
					if(p[j]<p[j+1])
					{
						t=p[j];
						p[j]=p[j+1];
						p[j+1]=t;
					}
				}
			}
		 } 
		/**********  End  **********/

		int main()
		{
			ifstream infile("in.txt",ios::in); //定义输入文件流类对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出文件流类对象outfile
			//infile、outfile与cin、cout用法类似 

			char s[100];
			while(infile>>s)
			{
				fun(s);
				outfile<<s<<endl;
			}

			infile.close();
			outfile.close();
			return 0;
		}



69.             /*
		定义函数fun：根据p指针，计算该学生的4门课的平均分。
		学生记录由学号，姓名，四门课成绩，平均分组成。
		注意：请勿改动主函数main和其它函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		----------------------------------------------------------------------------------------*/
		#include<iostream> 
		#include<fstream> 
		using namespace std;
		struct student
		{
			int id;
			char name[20];
			int score[4];
			int avg;
		};
		void fun(student* p)
		{
			/*************begin **************/
			int s=0;
			for(int i=0;i<4;i++)
			{
				s+=p->score[i];
			  }
			  p->avg=s/4;
			/****************end****************/

		}

		int main()
		{
			student stu;
			int i;
			ifstream ifile("in.txt");
			ofstream ofile("out.txt"); 
			while(!ifile.eof())
			{
			ifile>>stu.id;     //从文件读入学号
			ifile>>stu.name;   //从文件读入姓名
			for(i=0;i<4;i++) 
				ifile>>stu.score[i];   //从文件读入四门课的成绩
			fun(&stu); 
			cout<<stu.id<<" "<<stu.name<<" ";
			for(i=0;i<4;i++)
				cout<<stu.score[i]<<" ";
			cout<<"平均成绩:"<<stu.avg<<endl;
			    //输出到out.txt文件 
			ofile<<stu.id<<" "<<stu.name<<" ";
			for(i=0;i<4;i++)
				ofile<<stu.score[i]<<" ";
			ofile<<"平均成绩:"<<stu.avg<<endl;
			} 
			ifile.close();   //关闭输入文件in.txt
			ofile.close();   //关闭输出文件out.txt
			return 0;
		}



70.              /*
		定义函数fun：根据p指针，计算该学生的4门课的平均分。
		学生记录由学号，姓名，四门课成绩，平均分组成。
		注意：请勿改动主函数main和其它函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		----------------------------------------------------------------------------------------*/
		#include<iostream> 
		#include<fstream> 
		using namespace std;
		struct student
		{
			int id;
			char name[20];
			int score[4];
			int avg;
		};
		void fun(student* p)
		{
			/*************begin **************/
			int s=0;
			for(int i=0;i<4;i++)
			{
				s+=p->score[i];
			  }
			  p->avg=s/4;
			/****************end****************/

		}

		int main()
		{
			student stu;
			int i;
			ifstream ifile("in.txt");
			ofstream ofile("out.txt"); 
			while(!ifile.eof())
			{
			ifile>>stu.id;     //从文件读入学号
			ifile>>stu.name;   //从文件读入姓名
			for(i=0;i<4;i++) 
				ifile>>stu.score[i];   //从文件读入四门课的成绩
			fun(&stu); 
			cout<<stu.id<<" "<<stu.name<<" ";
			for(i=0;i<4;i++)
				cout<<stu.score[i]<<" ";
			cout<<"平均成绩:"<<stu.avg<<endl;
			    //输出到out.txt文件 
			ofile<<stu.id<<" "<<stu.name<<" ";
			for(i=0;i<4;i++)
				ofile<<stu.score[i]<<" ";
			ofile<<"平均成绩:"<<stu.avg<<endl;
			} 
			ifile.close();   //关闭输入文件in.txt
			ofile.close();   //关闭输出文件out.txt
			return 0;
		}





71.             /*字符串的截取:编写一个函数char * substr(char *s, int begin, int end，char *s1)，
		用于取得字符串s中从begin位置开始至end位置结束（包括begin和end位置上的字符，位置从0开始计算）的子字符串，将该子字符串存放在s1中。
		如：in.txt
		This is a wonderful world!
		10 18
		则:out.txt
		wonderful
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		#include <string.h>
		using namespace std;
		void substr(char *s, int begin, int end,char *s1)
		{
		/********************************* Begin ****************************/
		 int t=0;
		 for(int i=begin;i<=end;i++)
		 {
			s1[t]=s[i];
			t++;
		  } 
		  s1[t]='\0';
		/********************************* End ******************************/
		}
		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char s[100];
		       char s1[100];
			int m,n;
			cin.getline(s,100);
			cin>>m>>n;
			substr(s, m, n,s1);
			cout<<s1<<endl;

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}



72.              /*编写函数fun找出一维整型数组元素中最大的值和它所在的下标，最大的值和它所在的下标通过形参传回。
		如：in.txt
		1 2 13 14 23 15 21 60 35 23
		则:out.txt
		max=60，index=7
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std; 
		void fun(int a[], int n , int  *max, int  *d )//n为数组a存放的数组个数 
		{
		    /**********  Begin  **********/
			for(int i=0;i<n;i++)
			{
				if(a[i]>*max)
				{
					*max=a[i];
					*d=i;
				}
			 } 
		    /**********   End  ***********/
		}
		int main()
		{ 
			ifstream infile("in.txt",ios::in);//定义输入文件流类对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出文件流类对象outfile
			//infile与cin用法相同，outfile与cout用法相同。 

			int a[20],max,index,n=0;
			while(infile>>a[n])
				n++;

			fun(a,n,&max,&index);

			outfile<<"Max="<<max<<",Index="<<index<<'\n';

			infile.close();
			outfile.close(); 
			return 0;
		}




73.             /*
		设计函数fun:从保存n个学生记录的stu1数组中，找出低于平均分的学生数据，并保存在sut2数组中，函数返回值表示找到的学生人数。
		学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组中。
		请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		-------------------------------------------------------------------------------------------------------------------------*/
		#include <iostream>
		using namespace std;
		#include<fstream>
		#include<iomanip>
		#define N 8 
		struct student
		{   
		   char num[10];
		    int score;
		};
		int fun(student stu1[],int n,student stu2[])
		{

		    /**********  Begin  **********/
		float s=0,aver;
		for(int i=0;i<n;i++)                  //求平均分
		{
			s+=stu1[i].score;
		 }
		aver=s/n;
		int t=0;
		for(int i=0;i<n;i++)
		{
			if(stu1[i].score<aver)
			{
				stu2[t]=stu1[i];
				t++;
			}
		}
		return t;
		    /**********   End  ***********/
		}

		int main()
		{  
			student stu1[N]={{"GA05",85},{"GA03",76},{"GA02",69},{"GA04",85},{"GA01",91},{"GA07",72},{"GA08",64},{"GA06",87}};
			student stu2[N];
			int i,n;
			n=fun(stu1,N,stu2);
			cout<<"所有学生数据："<<endl;
			for(i=0;i<N;i++)
			cout<<stu1[i].num<<setw(4)<<stu1[i].score<<endl;
		      cout<<n<<endl;	
			cout<<"低于平均分学生数据："<<endl;
			for(i=0;i<n;i++)
			cout<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;

			//结果写入out.txt 
			ofstream ofile; 
			ofile.open("out.txt");
			ofile<<n<<endl;
			for(i=0;i<n;i++)
			ofile<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;
			ofile.close();
		}



74.               /*
		基于下面的main()函数，写出完整的程序，能够编译和运行；
		程序中的输入文件in.txt包含以下数据：
		1001
		1002
		1003
		定义类Student，包括私有成员变量学号(int)，包括构造函数和析构函数,使得输出文件out.txt包含以下数据： 
		Constructor1001
		Constructor1002
		Constructor1003
		Destructor1003
		Destructor1002
		Destructor1001
		提示：程序使用文件实现输入和输出，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/********************** Begin *******************/
		class Student 
		{
			private:
				int name;
			public:
				Student(int N)
				{
					name=N;
					outfile<<"Constructor"<<name<<endl;
				}
				~Student()
				{
					outfile<<"Destructor"<<name<<endl;
				}
		};
		/********************** End *********************/

		void  CreateObjects()
		{
		       int n[3];
			infile>>n[0]>>n[1]>>n[2];
			Student s1[3]={n[0],n[1],n[2]};
		}
		int main()
		{

		  if(!infile) return -1;
		  if(!outfile) return -1;

		  CreateObjects();
		  infile.close();
		  outfile.close();
		  return 0;
		}



75.             /*
		定义学生类Student，包括私有成员变量学号(int)、性别(char)、年龄(int)，包括构造函数，用于对私有成员初始化； 
		成员函数Display(ostream &output)用于输出：学号(int)、性别(char)、年龄(int)，将这些数据输出到输出流；
		程序中的输入文件in.txt包含以下数据（3列数据分别表示学号、性别、年龄） ：
		1001 f 18
		1002 m 19
		1003 m 17
		1004 f 18
		1005 f 19
		输出文件out.txt包含以下数据(数据之间用一个空格隔开）：
		1001	f	18
		1002	m	19
		1003	m	17
		1004	f	18
		1005	f	19
		程序从文件in.txt中读取数据，输出到文件out.txt中，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。  
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/*************************** Begin ************************/
		class Student
		{
			private:
				int a;char b;int c;
			public:
				Student(int x,char y,int z)
				{
					a=x;b=y;c=z;
				}
				Display(ostream&output)
				{
					outfile<<a<<" "<<b<<" "<<c<<endl;
				}
		 } ;
		/*************************** End **************************/

		int main()
		{
			if(!infile) return -1;
			if(!outfile) return -1;
			int n;char s;int a;
			while(!infile.eof())
			{
				infile>>n>>s>>a;
				Student s1(n,s,a);
				s1.Display(outfile);
			}
			infile.close();
			outfile.close();
			return 0;
		}



76.             /*编写函数fun实现将字符串按字符降序排列。
		如：in.txt
		CEAedcab
		则:out.txt
		edcbaECA
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句 
		---------------------------------------------------------------------------------------------------*/
		#include<fstream>
		#include<string.h>
		using namespace std;

		/**********Begin**********/
		void fun(char s[])
		{
			char k;
			int n=sizeof(s);
			for(int i=0;i<n-1;i++)
			{
				for(int t=0;t<n-i-1;t++)
				{
					if(s[t]<s[t+1])
					{
						k=s[t];s[t]=s[t+1];s[t+1]=k;
					}
				}
			}
		 } 
		/**********  End  **********/

		int main()
		{
			ifstream infile("in.txt",ios::in); //定义输入文件流类对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出文件流类对象outfile
			//infile、outfile与cin、cout用法类似 

			char s[100];
			while(infile>>s)
			{
				fun(s);
				outfile<<s<<endl;
			}

			infile.close();
			outfile.close();
			return 0;
		}



77.             /*编写函数fun：将一个字符串中的大写字母转换成小写，小写转换成大写，其它字符保持不变。 
		如:in.txt
		HappyNew2019Year
		则:out.txt
		hAPPYnEW2019yEAR
		请在Begin和End之间完善程序。注意：不要删掉注释语句。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream> 
		using namespace std;
		#include <string.h> 
		/***********Begin**********/
		void fun(char str[])
		 {
			int n=sizeof(str);
			for(int i=0;i<n;i++)
			{
				if(str[i]>='a'&&str[i]<='z')
				str[i]-=32;
				else if(str[i]>='A'&&str[i]<='Z')
				str[i]+=32;
			 }
		 }
		/***********End***********/

		int main()
		{
			ifstream infile("in.txt",ios::in);//定义输入流文件对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出流文件对象outfile 
			//infile、outfile的用法同cin、cout
			char str[100];
		      while(!infile.eof())
		     {
		       infile.getline(str,100);//从文件in.txt中读入字符串到数组str中 
			fun(str);
			outfile<<str<<endl; //输出字符串到文件out.txt中 
		     }
			infile.close();
			outfile.close();
			return 0;
		}




78.             /*
		定义函数fun：在n个学生记录中，根据学生的学号，查找该学生对应的成绩，若没有该学号，则返回-1。
		学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组s中，要查找的学生学号从文件读入，依次将学生的学号和查找结果存放在输出文件中。
		（用于字符串比较的函数是strcmp）。
		例如in.txt中显示：
		GA09
		GA010
		GA011
		则out.txt中输出：
		GA09 -1
		GA010 -1
		GA011 91
		注意：请勿改动主函数main和其它函数中的任何内容，只能在begin与end之间写代码。
		------------------------------------------------------------------------------------------*/
		#include<iostream>
		#include<cstring>
		#include<fstream>
		using namespace std;
		#define N 16
		struct student
		{   char num[10];
		    int score;
		} ;
		int fun (student stu[],int n, char num[])
		{
		 /**********  Begin  **********/
		 int t=0;
		  for (int i=0;i<n;i++)
		  {
			if(strcmp(stu[i].num,num)==0)
			{
			  t=1;
			  return stu[i].score;
			  break;
			}
		   } 
		   if(t==0)
		   return -1;
		 /**********   End  ***********/

		}

		int main()
		{ ifstream infile("in.txt",ios::in); 
		  ofstream outfile("out.txt",ios::out);
		  student s[N]={{"GA05",85},{"GA03",76},{"GA02",69},{"GA04",85},{"GA01",91},{"GA07",72},{"GA08",64},{"GA06",87},{"GA015",85},{"GA013",91},{"GA012",64},{"GA014",91},{"GA011",91},{"GA017",64},{"GA018",64},{"GA016",72}};
		  int score;
		  char num[10];//保存要查找学号  
		  while(infile>>num)
		  { 
			score=fun(s,N,num);
			outfile<<num<<" "<<score<<endl; 
		  }
		  infile.close();
		  outfile.close();
		  return 0;
		}




79.              /*
		定义箱子类Box，包括私有成员变量高度height(int)、宽度width(int)、长度length(int)，
		包括构造函数和成员函数volume()； 
		构造函数要能够实现main()函数中对象box1,box2,box3,box4的正确构造；
		成员函数volume(),求箱子的体积:height*width*length
		程序中的输入文件in.txt包含以下数据:
		(共2组数据，第1组中第1个箱子的height*width*length为5*3*2，第3个箱子的height*width为2*3)
		5 3 2
		2 3
		6 3 5
		5 3
		输出文件out.txt包含以下数据:
		30
		30
		60
		60
		90
		90
		150
		150
		程序从文件in.txt中读取数据，输出到文件out.txt中，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		--------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/*************************** Begin ***********************/
		class Box
		{
			private:
				int t;int w;int l;
			public:
				Box(int a=10,int b=10,int c=10)
				{
					t=a;w=b;l=c;
				}
				int volume(void)
				{
					return t*w*l;
				}
		 } ;
		/*************************** End *************************/

		int main( )
		{
		 if(!infile) return -1;
		 if(!outfile) return -1;
		  int n1,n2,n3;
		  while(!infile.eof())
		  {
			infile>>n1>>n2>>n3;
			Box box1(n1,n2,n3),box2;
			box2=box1;
			infile>>n1>>n2;
			Box box3(n1,n2);
			Box box4(box3);
			outfile<<box1.volume()<<'\n'<<box2.volume()<<'\n'
			<<box3.volume()<<'\n'<<box4.volume()<<endl; 
		  }
		  infile.close();
		  outfile.close();
		  return 0;
		}




80.              /*
		基于下面的main()函数，写出完整的程序，能够编译和运行；
		程序中的输入文件in.txt包含以下数据
		6S
		6Plus
		7S
		7Plus 
		定义类Apple，包括私有成员变量name(string)，包括构造函数和析构函数,使得输出文件out.txt包含以下数据 
		Apple6S
		~Apple6S
		Apple6Plus
		~Apple6Plus
		Apple7S
		~Apple7S
		Apple7Plus
		~Apple7Plus
		提示：程序使用文件实现输入和输出，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		---------------------------------------------------------------------------------------------------*/
		#include<string>
		#include<fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/******************** Begin ****************/
		class Apple
		{
			private:
				string name;
			public:
				Apple(string N)
				{
					name=N;
					outfile<<"Apple"<<name<<endl;
				}
				~Apple()
				{
					outfile<<"~Apple"<<name<<endl;
				}
		 } ;
		/******************** End ******************/

		int main()
		{
		    if(!infile) return -1;
		    if(!outfile) return -1;

		    string name;
		    while(infile>>name)
		    {
			Apple *pA = new Apple(name);
		       delete pA;
		    }	

		    infile.close();
		    outfile.close();
		    return 0;
		}




81.              /*查找字符串
		编写一个函数实现：在一个字符串中查找另一个给定的字符串首次出现的位置。
		int find(char * strSrc, char * strFind)
		该函数在字符串strSrc中查找字符串srcFind首次出现的位置，并返回一个整数表示该位置，返回-1表示查找失败或未找到。
		如：in.txt
		Welcome to the C++ world!
		C++
		WelcomeC++ to the C++ world!
		C++
		C++Welcome to the world!
		C++
		Welcome to the worldC++
		C++
		Welcome to the worldC+
		C++        
		则:out.txt
		16
		8
		1
		21
		-1
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include<iostream>
		#include <string.h>
		using namespace std;
		int find(char * strSrc, char * strFind)
		{
		/***************************** Begin ******************************/
		int n1=strlen(strSrc),n2=strlen(strFind);                 //表示没有字符
		int i,j;
		if(n1<n2)
		return -1;
		for(i=0;i<n1-n2;i++)
		{
			for(j=0;j<n2;j++)
			{
				if(strSrc[i+j]!=strFind[j])
				break;
			}
			if(j==n2)
			return i+1;	
		}
		return -1;
		/***************************** End ********************************/
		}

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char strSrc[100],strFind[100];
			while(cin.getline(strSrc,100)&&cin.getline(strFind,100))
				cout<<find(strSrc,strFind)<<"\n";

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}




82.             /*字符串的截取:编写一个函数char * substr(char *s, int begin, int end，char *s1)，
		用于取得字符串s中从begin位置开始至end位置结束（包括begin和end位置上的字符，位置从0开始计算）的子字符串，将该子字符串存放在s1中。
		如：in.txt
		This is a wonderful world!
		10 18
		则:out.txt
		wonderful
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		#include <string.h>
		using namespace std;
		void substr(char *s, int begin, int end,char *s1)
		{
		/********************************* Begin ****************************/
		int n=strlen(s),t=0;
		for(int i=begin;i<=end;i++)
		{
			s1[t]=s[i];
			t++;
		 } 
		 s1[t]='\0';
		/********************************* End ******************************/
		}
		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char s[100];
		       char s1[100];
			int m,n;
			cin.getline(s,100);
			cin>>m>>n;
			substr(s, m, n,s1);
			cout<<s1<<endl;

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}




83.              /*编写函数fun找出一维整型数组元素中最大的值和它所在的下标，最大的值和它所在的下标通过形参传回。
		如：in.txt
		1 2 13 14 23 15 21 60 35 23
		则:out.txt
		max=60，index=7
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std; 
		void fun(int a[], int n , int  *max, int  *d )//n为数组a存放的数组个数 
		{
		    /**********  Begin  **********/
			for(int i=0;i<n;i++)
			{
				if(a[i]>*max)
				{
					*max=a[i];
					*d=i;
				}
			 } 
		    /**********   End  ***********/
		}
		int main()
		{ 
			ifstream infile("in.txt",ios::in);//定义输入文件流类对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出文件流类对象outfile
			//infile与cin用法相同，outfile与cout用法相同。 

			int a[20],max,index,n=0;
			while(infile>>a[n])
				n++;

			fun(a,n,&max,&index);

			outfile<<"Max="<<max<<",Index="<<index<<'\n';

			infile.close();
			outfile.close(); 
			return 0;
		}




84.              /*
		设计函数fun:从保存n个学生记录的stu1数组中，找出低于平均分的学生数据，并保存在sut2数组中，函数返回值表示找到的学生人数。
		学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组中。
		请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		-------------------------------------------------------------------------------------------------------------------------*/
		#include <iostream>
		using namespace std;
		#include<fstream>
		#include<iomanip>
		#define N 8 
		struct student
		{   
		   char num[10];
		    int score;
		};
		int fun(student stu1[],int n,student stu2[])
		{

		    /**********  Begin  **********/
		float s=0,aver;
		int t=0;
		for(int i=0;i<n;i++)
		s+=stu1[i].score;
		aver=s/n; 
		for(int i=0;i<n;i++)
		{
			if(stu1[i].score<aver)
			{
				stu2[t]=stu1[i];
				t++;
			}
		}
		return t;
		    /**********   End  ***********/
		}

		int main()
		{  
			student stu1[N]={{"GA05",85},{"GA03",76},{"GA02",69},{"GA04",85},{"GA01",91},{"GA07",72},{"GA08",64},{"GA06",87}};
			student stu2[N];
			int i,n;
			n=fun(stu1,N,stu2);
			cout<<"所有学生数据："<<endl;
			for(i=0;i<N;i++)
			cout<<stu1[i].num<<setw(4)<<stu1[i].score<<endl;
		      cout<<n<<endl;	
			cout<<"低于平均分学生数据："<<endl;
			for(i=0;i<n;i++)
			cout<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;

			//结果写入out.txt 
			ofstream ofile; 
			ofile.open("out.txt");
			ofile<<n<<endl;
			for(i=0;i<n;i++)
			ofile<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;
			ofile.close();
		}





85.             /*
		基于下面的main()函数，写出完整的程序，能够编译和运行；
		程序中的输入文件in.txt包含以下数据：
		1001
		1002
		1003
		定义类Student，包括私有成员变量学号(int)，包括构造函数和析构函数,使得输出文件out.txt包含以下数据： 
		Constructor1001
		Constructor1002
		Constructor1003
		Destructor1003
		Destructor1002
		Destructor1001
		提示：程序使用文件实现输入和输出，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/********************** Begin *******************/
		class Student
		{
			private:
				int name;
			public:
				Student(int N)
				{
					name=N;
					outfile<<"Constructor"<<name<<endl;
				}
				~Student()
				{
					outfile<<"Destructor"<<name<<endl;
				}
		 } ;
		/********************** End *********************/

		void  CreateObjects()
		{
		       int n[3];
			infile>>n[0]>>n[1]>>n[2];
			Student s1[3]={n[0],n[1],n[2]};
		}
		int main()
		{

		  if(!infile) return -1;
		  if(!outfile) return -1;

		  CreateObjects();
		  infile.close();
		  outfile.close();
		  return 0;
		}




86.             /*
		定义学生类Student，包括私有成员变量学号(int)、性别(char)、年龄(int)，包括构造函数，用于对私有成员初始化； 
		成员函数Display(ostream &output)用于输出：学号(int)、性别(char)、年龄(int)，将这些数据输出到输出流；
		程序中的输入文件in.txt包含以下数据（3列数据分别表示学号、性别、年龄） ：
		1001 f 18
		1002 m 19
		1003 m 17
		1004 f 18
		1005 f 19
		输出文件out.txt包含以下数据(数据之间用一个空格隔开）：
		1001	f	18
		1002	m	19
		1003	m	17
		1004	f	18
		1005	f	19
		程序从文件in.txt中读取数据，输出到文件out.txt中，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。  
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/*************************** Begin ************************/
		class Student
		{
			private:
				int a;char b;int c;
			public:
				Student(int x,char y,int z)
				{
					a=x;b=y;c=z;
				}
				void Display(ostream &output)
				{
					outfile<<a<<" "<<b<<" "<<c<<endl;
				}
		 } ;
		/*************************** End **************************/

		int main()
		{
			if(!infile) return -1;
			if(!outfile) return -1;
			int n;char s;int a;
			while(!infile.eof())
			{
				infile>>n>>s>>a;
				Student s1(n,s,a);
				s1.Display(outfile);
			}
			infile.close();
			outfile.close();
			return 0;
		} 




87.             /*插入字符串
		编写一个函数实现：把一个字符串插入到另一个字符串中的指定位置。
		void copys2s(char * src,char * dest,int loc)
		该函数实现将字符串dest插入字符串src中loc的位置。该函数定义可以使用字符串处理函数。
		如：in.txt
		abcdef
		123
		3
		abcdef
		123
		1
		abcdef
		123
		7       
		则：out.txt
		ab123cdef
		123abcdef
		abcdef123
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include<iostream>
		#include <string.h>
		using namespace std;
		void copys2s(char * src,char * dest,int loc)
		{
		/************************* Begin *************************/
		char temp[100];
		strcpy(temp,src+loc-1);
		strcpy(src+loc-1,dest);
		int n=strlen(src);
		strcpy(src+n,temp);
		/************************* End ***************************/
		}
		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

		    char src[100],dest[100];
		    int loc;
		    while(cin>>src>>dest>>loc)
		    {
			copys2s(src,dest,loc);
			cout<<src<<endl;
		    }

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}
		
		
		
88.		/* 回文字符串（指针版）:
		写程序，输入多个字符串，判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO.
		每个输入的字符串的前端或后端可能包含多个空格，不算作字符串的一部分，不参与判断过程，应该先裁剪掉。
		字符串的内部包含的空格，算作字符串的一部分，要参与判断的过程。
		每个字符串的输入长度（包括所有的空格）不超过100，使用指针pi和pj完成计算过程，定义如下：
		char s[100], *pi, *pj;
		输入包括多个用例，每个用例包含一个字符串（前端或后端或内部可能包含多个空格，字符串的长度不超过100），以换行作为字符串的结束。
		判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO，以换行结束。
		如：in.txt
		abc  cba
		      abc 12321 cba
		      abc 1221 cba
		abc 123321 cba
		abc 123321  cba
		则:out.txt
		YES
		YES
		YES
		YES
		NO
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		#include <string.h>
		using namespace std;

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char s[100], *pi, *pj;
			int  n;
			while(cin.getline(s,100))
			{
		/********************************* Begin ****************************/
		n=strlen(s);
		char *p1=s,*p2=s+n-1;
		//删除前后空格
		while(*p1==' ')
		{
			p1++;
		 } 
		while(*p2==' ')
		{
			p2--;
		 } 
		//开始比较
		while((p1<p2)&&(*p1==*p2))
		{
			p1++;p2--;
		 } 
		if(p1<p2)
		cout<<"NO"<<endl;
		else
		cout<<"YES"<<endl;
		/********************************* End ******************************/
			}

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}




89.             /*删除升序数组中的重复元素（指针版）
		编写程序，删除一维数组中所有相同的数，只保留一个，数组中的数已按由小到大的顺序排列，
		int unique(int *pArr,int num)
		pArr和num分别为数组首地址和数组元素的个数，函数返回删除重复元素之后数组中元素个数。
		如：in.txt
		2 2 2 3 4 4 5 6 6 6 6 7 7 8 9 9 10 10 10
		则：out.txt
		2 3 4 5 6 7 8 9 10
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		using namespace std;
		int unique(int *pArr,int num)
		{
		/********************************** Begin ****************************/
		int *p=pArr;               //用p存放新的数组 
		for(int i=0;i<num-1;i++)
		{
			if(pArr[i+1]!=pArr[i])
			{
				p++;
				*p=pArr[i+1];
			}
		 } 
		 int n=p-pArr+1;           //指针可以相减 
		 return n;
		/********************************** End ******************************/
		}
		int main()
		{
			ofstream file_out("out.txt"); 
			if(!file_out) return -1;
			streambuf *std_out;
			std_out= cout.rdbuf(file_out.rdbuf());  

			int a[]={2,2,2,3,4,4,5,6,6,6,6,7,7,8,9,9,10,10,10};
			int num1 = sizeof(a)/sizeof(int);
			int num2 = unique(a,num1);

			cout<<a[0];
			for (int i=1;i<num2;i++)
			{
				cout<<" "<<a[i];
			}
			cout<<'\n';

			file_out.close();
			cout.rdbuf(std_out);	
			return 0;
		}




90.             /*编写函数fun：将一个字符串中的大写字母转换成小写，小写转换成大写，其它字符保持不变。 
		如:in.txt
		HappyNew2019Year
		则:out.txt
		hAPPYnEW2019yEAR
		请在Begin和End之间完善程序。注意：不要删掉注释语句。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream> 
		using namespace std;
		#include <string.h> 
		/***********Begin**********/
		void fun(char *s)
		{
			char *p = s;
			while(*p!=0)
			{
				if(*p>='A'&&*p<='Z')
					*p = *p+32;
				else
					if(*p>='a'&&*p<='z')
						*p = *p-32;
				p++;
			}
		}
		/***********End***********/

		int main()
		{
			ifstream infile("in.txt",ios::in);//定义输入流文件对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出流文件对象outfile 
			//infile、outfile的用法同cin、cout
			char str[100];
		      while(!infile.eof())
		     {
		       infile.getline(str,100);//从文件in.txt中读入字符串到数组str中 
			fun(str);
			outfile<<str<<endl; //输出字符串到文件out.txt中 
		     }
			infile.close();
			outfile.close();
			return 0;
		}




91.              /*
		定义电影类Movie，包括私有对象成员电影名name(string)，开始时间startTime和结束时间endTime；
		startTime和endTime是Time类的对象；Time类包括公有成员hour(int)，minute(int)和构造函数； 
		Movie类包括构造函数，求电影时长(多少分钟)的函数 int Duration()，显示电影播放信息的函数Display(ofstream &output); 
		程序中的输入文件in.txt包含以下数据:
		The Fast and the Furious 8
		12 30 14 50
		Smurfs: The Lost Village
		13 9 15 45
		Battle of Memories
		15 20 16 54
		输出文件out.txt包含以下数据（英文冒号）：
		The Fast and the Furious 8
		start time:12:30
		140minutes
		Smurfs: The Lost Village
		start time:13:9
		156minutes
		Battle of Memories
		start time:15:20
		94minutes
		程序从文件in.txt中读取数据，输出到文件out.txt中，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		----------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/****************************** Begin ************************/
		class Time
		{
			public:
				int hour;
				int minute;
				Time(int a=0,int b=0)
				{
					hour=a;minute=b;
				}
		};
		class Movie
		{
			private:
				string name;
				Time startTime,endTime;
			public:
				Movie(string a,Time &b,Time &c)
				{
					name=a;startTime=b;endTime=c;
				}
				int Duration()
				{
					int t;
					t=(endTime.hour-startTime.hour)*60+(endTime.minute-startTime.minute);
					return t;
				}
				void Display(ofstream &output)
				{
					output<<name<<'\n'<<"start time:"<<startTime.hour<<':'<<startTime.minute<<'\n';
				}
		 }; 
		/****************************** End **************************/

		int main()
		{ 
			if(!infile) return -1;
			if(!outfile) return -1;

			string str;
			int hour1,minute1,hour2,minute2;

			while(!infile.eof())
			{
				getline(infile,str);
				infile>>hour1>>minute1>>hour2>>minute2;
				infile.ignore();
				Time startT(hour1,minute1),endT(hour2,minute2);
				Movie mov(str,startT,endT);
				mov.Display(outfile);
				outfile<<mov.Duration()<<"minutes"<<endl;
			}

			infile.close();
			outfile.close();	
			return 0;
		}




92.             /* 回文字符串（指针版）:
		写程序，输入多个字符串，判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO.
		每个输入的字符串的前端或后端可能包含多个空格，不算作字符串的一部分，不参与判断过程，应该先裁剪掉。
		字符串的内部包含的空格，算作字符串的一部分，要参与判断的过程。
		每个字符串的输入长度（包括所有的空格）不超过100，使用指针pi和pj完成计算过程，定义如下：
		char s[100], *pi, *pj;
		输入包括多个用例，每个用例包含一个字符串（前端或后端或内部可能包含多个空格，字符串的长度不超过100），以换行作为字符串的结束。
		判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO，以换行结束。
		如：in.txt
		abc  cba
		      abc 12321 cba
		      abc 1221 cba
		abc 123321 cba
		abc 123321  cba
		则:out.txt
		YES
		YES
		YES
		YES
		NO
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		#include <string.h>
		using namespace std;

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char s[100], *pi, *pj;
			int  n;
			while(cin.getline(s,100))
			{
		/********************************* Begin ****************************/
		n=strlen(s);
		char *p1=s,*p2=s+n-1;
		while(*p1==' ')
		{
			p1++;
		 } 
		while(*p2==' ')
		{
			p2--;
		}
		while((p1<p2)&&(*p1==*p2))
		{
			p1++;p2--;
		}
		if(p1<p2)
		cout<<"NO"<<endl;
		else
		cout<<"YES"<<endl;
		/********************************* End ******************************/
			}

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}



93.             /*删除升序数组中的重复元素（指针版）
		编写程序，删除一维数组中所有相同的数，只保留一个，数组中的数已按由小到大的顺序排列，
		int unique(int *pArr,int num)
		pArr和num分别为数组首地址和数组元素的个数，函数返回删除重复元素之后数组中元素个数。
		如：in.txt
		2 2 2 3 4 4 5 6 6 6 6 7 7 8 9 9 10 10 10
		则：out.txt
		2 3 4 5 6 7 8 9 10
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		using namespace std;
		int unique(int *pArr,int num)
		{
		/********************************** Begin ****************************/
		int *p=pArr;
		for(int i=0;i<num-1;i++)
		{
			if(pArr[i+1]!=pArr[i])
			{
				p++;
				*p=pArr[i+1];
			}
		 } 
		 return p-pArr+1;
		/********************************** End ******************************/
		}
		int main()
		{
			ofstream file_out("out.txt"); 
			if(!file_out) return -1;
			streambuf *std_out;
			std_out= cout.rdbuf(file_out.rdbuf());  

			int a[]={2,2,2,3,4,4,5,6,6,6,6,7,7,8,9,9,10,10,10};
			int num1 = sizeof(a)/sizeof(int);
			int num2 = unique(a,num1);

			cout<<a[0];
			for (int i=1;i<num2;i++)
			{
				cout<<" "<<a[i];
			}
			cout<<'\n';

			file_out.close();
			cout.rdbuf(std_out);	
			return 0;
		}



94.             /*编写函数fun：将一个字符串中的大写字母转换成小写，小写转换成大写，其它字符保持不变。 
		如:in.txt
		HappyNew2019Year
		则:out.txt
		hAPPYnEW2019yEAR
		请在Begin和End之间完善程序。注意：不要删掉注释语句。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream> 
		using namespace std;
		#include <string.h> 
		/***********Begin**********/
		void fun(char str[])
		{
			int n=strlen(str);
			for(int i=0;i<n;i++)
			{
				if(str[i]>='a'&&str[i]<='z')
				str[i]-=32;
				else if(str[i]>='A'&&str[i]<='Z')
				str[i]+=32;
			}
		 } 
		/***********End***********/

		int main()
		{
			ifstream infile("in.txt",ios::in);//定义输入流文件对象infile 
			ofstream outfile("out.txt",ios::out);//定义输出流文件对象outfile 
			//infile、outfile的用法同cin、cout
			char str[100];
		      while(!infile.eof())
		     {
		       infile.getline(str,100);//从文件in.txt中读入字符串到数组str中 
			fun(str);
			outfile<<str<<endl; //输出字符串到文件out.txt中 
		     }
			infile.close();
			outfile.close();
			return 0;
		}




95.             /*查找字符串
		编写一个函数实现：在一个字符串中查找另一个给定的字符串首次出现的位置。
		int find(char * strSrc, char * strFind)
		该函数在字符串strSrc中查找字符串srcFind首次出现的位置，并返回一个整数表示该位置，返回-1表示查找失败或未找到。
		如：in.txt
		Welcome to the C++ world!
		C++
		WelcomeC++ to the C++ world!
		C++
		C++Welcome to the world!
		C++
		Welcome to the worldC++
		C++
		Welcome to the worldC+
		C++        
		则:out.txt
		16
		8
		1
		21
		-1
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include<iostream>
		#include <string.h>
		using namespace std;
		int find(char * strSrc, char * strFind)
		{
		/***************************** Begin ******************************/
		int n1=strlen(strSrc),n2=strlen(strFind);
		int i,j;
		if(n1<n2)
		return -1;
		for(i=0;i<=n1-n2;i++)
		{
			for(j=0;j<n2;j++)
			{
				if(strSrc[i+j]!=strFind[j])
				break;
			}
			if(j==n2)
			return i+1;
		 } 
		 return -1;
		/***************************** End ********************************/
		}

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char strSrc[100],strFind[100];
			while(cin.getline(strSrc,100)&&cin.getline(strFind,100))
				cout<<find(strSrc,strFind)<<"\n";

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}




96.             /*请编写一个函数fun,将一个数字字符串转换为一个整数。
		如：in.txt
		-1234
		则:out.txt
		-1234
		注意:请勿改动现有任何内容，仅在Begin和End之间补充代码。
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		using namespace std; 
		 /**********  Begin  **********/
		 int fun(char *s)
		 {
			int flag=1;
			if (*s=='-')
			{
				flag=-1;
				s++;
			 }
			int p=0;
			while(*s)
			{
				p=p*10+(*s-48);
				s++;
			 }
			 return p*flag;
		  } 
		 /**********   End  ***********/

		int main()
		{ 
			ifstream infile("in.txt",ios::in);    //定义输入文件流类对象infile
			ofstream outfile("out.txt",ios::out); //定义输出文件流类对象outfile
		      //infile、outfile与cin、cout用法相同

			char s[10];

			while(infile>>s)
				outfile<<fun(s)<<endl;

			infile.close();
			outfile.close();
			return 0;
		}




97.             /*编写函数fun实现两个整数的交换。
		如:in.txt
		60 65
		则:out.txt
		a=65 b=60
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include<fstream>
		using namespace std;
		void fun(int *a,int *b)
		{
		  /**********Begin**********/
		int t;
		t=*a;*a=*b;*b=t; 
		  /**********  End  **********/
		} 
		int main()
		{
		  ifstream infile("in.txt",ios::in);  //创建输入文件流类对象infile 
		  ofstream outfile("out.txt",ios::out);//创建输出文件流类对象outfile
		  //infile和outfile用法与cin和cout一样 

		  int a,b;
		  while(infile>>a>>b)
		  {   
		    fun(&a,&b);
		    outfile<<"a="<<a<<' '<<"b="<<b<<'\n';
		  }

		  infile.close();   //关闭文件in.txt 
		  outfile.close();	//关闭文件out.txt 
		  return 0;
		}



98.              /*
		设计函数fun:从保存n个学生记录的stu1数组中，找出成绩在60和80分之间（包括60和80）的学生数据，并保存在sut2数组中，函数返回值表示找到的学生人数。
		其中，学生记录由学号和成绩组成。
		请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		------------------------------------------------------------------------------------------------------------------------------------*/
		#include <iostream>
		using namespace std;
		#include<fstream>
		#include<iomanip>
		#define N 16
		struct student
		{   
		   char num[10];
		    int score;
		};
		int fun(student stu1[],int n,student stu2[])
		{

		    /**********  Begin  **********/
		    int t=0;
		for(int i=0;i<n;i++)
		{
			if(stu1[i].score>=60&&stu1[i].score<=80)
			{
				stu2[t]=stu1[i];
				t++;
			}
		 } 
		 return t;
		    /**********   End  ***********/

		}

		int main()
		{  
			student stu1[N]={{"GA05",85},{"GA03",76},{"GA02",69},{"GA04",85},{"GA01",91},{"GA07",72},{"GA08",64},{"GA06",87},{"GA015",85},{"GA013",91},{"GA012",64},{"GA014",91},{"GA011",91},{"GA017",64},{"GA018",64},{"GA016",72}};
			student stu2[N];
			int i,n;
			n=fun(stu1,N,stu2);
			cout<<"所有的学生数据："<<endl;
			for(i=0;i<N;i++)
			cout<<stu1[i].num<<setw(4)<<stu1[i].score<<endl;
			cout<<"60-80分之间的学生数据："<<endl;
			for(i=0;i<n;i++)
			cout<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;

		       //结果写入out.txt 
			ofstream ofile; 
			ofile.open("out.txt");
			ofile<<n<<endl;
			for(i=0;i<n;i++)
			ofile<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;
			ofile.close();
		}







99.             /*
		基于下面的main()函数，写出完整的程序，能够编译和运行；
		程序中的输入文件in.txt包含以下数据:
		Huawei
		Sumsung
		iPhone7 
		定义类Phone，包括私有成员变量name(string)，包括构造函数，成员函数setName()修改name,
		常成员函数getName()获得name，使得输出文件out.txt包含以下数据;
		Huawei
		Sumsung
		iPhone7
		提示：程序使用文件实现输入和输出，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		---------------------------------------------------------------------------------------------------*/
		#include<string>
		#include<fstream>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/*************************** Begin **********************/
		class Phone
		{
			private:
				string name;
			public:
				Phone(){
				}
				Phone(string N)
				{
					name=N;
				}
				void setName(string n)
				{
					name=n; 
				}
				string getName() const
				{
					return name;
				}
		 } ;
		/*************************** End ************************/

		int main()
		{
			if(!infile) return -1;
			if(!outfile) return -1;

			Phone ph1,ph2;
			string name;
			infile>>name;
			ph1.setName(name);
			infile>>name;
			ph2.setName(name);
			Phone const *pPhone = &ph1;
			outfile<<pPhone->getName()<<endl;
			pPhone = &ph2;
			outfile<<pPhone->getName()<<endl;

			infile>>name;
			const Phone ph3(name);	
			outfile<<ph3.getName()<<endl;

			infile.close();
			outfile.close();
			return 0;
		}




100.		/*删除升序数组中的重复元素（指针版）
		编写程序，删除一维数组中所有相同的数，只保留一个，数组中的数已按由小到大的顺序排列，
		int unique(int *pArr,int num)
		pArr和num分别为数组首地址和数组元素的个数，函数返回删除重复元素之后数组中元素个数。
		如：in.txt
		2 2 2 3 4 4 5 6 6 6 6 7 7 8 9 9 10 10 10
		则：out.txt
		2 3 4 5 6 7 8 9 10
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		using namespace std;
		int unique(int *pArr,int num)
		{
		/********************************** Begin ****************************/
		int *p=pArr;
		for(int i=0;i<num-1;i++)
		{
			if(pArr[i+1]!=pArr[i])
			{	p++;
				*p=pArr[i+1];
			}
		 } 
		 return p-pArr+1;
		/********************************** End ******************************/
		}
		int main()
		{
			ofstream file_out("out.txt"); 
			if(!file_out) return -1;
			streambuf *std_out;
			std_out= cout.rdbuf(file_out.rdbuf());  

			int a[]={2,2,2,3,4,4,5,6,6,6,6,7,7,8,9,9,10,10,10};
			int num1 = sizeof(a)/sizeof(int);
			int num2 = unique(a,num1);

			cout<<a[0];
			for (int i=1;i<num2;i++)
			{
				cout<<" "<<a[i];
			}
			cout<<'\n';

			file_out.close();
			cout.rdbuf(std_out);	
			return 0;
		}




101.		/* 回文字符串（指针版）:
		写程序，输入多个字符串，判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO.
		每个输入的字符串的前端或后端可能包含多个空格，不算作字符串的一部分，不参与判断过程，应该先裁剪掉。
		字符串的内部包含的空格，算作字符串的一部分，要参与判断的过程。
		每个字符串的输入长度（包括所有的空格）不超过100，使用指针pi和pj完成计算过程，定义如下：
		char s[100], *pi, *pj;
		输入包括多个用例，每个用例包含一个字符串（前端或后端或内部可能包含多个空格，字符串的长度不超过100），以换行作为字符串的结束。
		判断输入的字符串是否"回文"，若是回文，输出YES，若不是回文输出NO，以换行结束。
		如：in.txt
		abc  cba
		      abc 12321 cba
		      abc 1221 cba
		abc 123321 cba
		abc 123321  cba
		则:out.txt
		YES
		YES
		YES
		YES
		NO
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iostream>
		#include <string.h>
		using namespace std;

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char s[100], *pi, *pj;
			int  n;
			while(cin.getline(s,100))
			{
		/********************************* Begin ****************************/
		n=strlen(s);
		char *p1=s,*p2=s+n-1;
		while(*p1==' ')
		{
			p1++;
		 } 
		 while(*p2==' ')
		 {
			p2--;
		 }
		 while((p1<p2)&&(*p1==*p2))
		 {
			p1++;p2--;
		 }
		 if(p1<p2)
		 cout<<"NO"<<endl;
		 else
		 cout<<"YES"<<endl;
		/********************************* End ******************************/
			}

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}



102.		/*查找字符串
		编写一个函数实现：在一个字符串中查找另一个给定的字符串首次出现的位置。
		int find(char * strSrc, char * strFind)
		该函数在字符串strSrc中查找字符串srcFind首次出现的位置，并返回一个整数表示该位置，返回-1表示查找失败或未找到。
		如：in.txt
		Welcome to the C++ world!
		C++
		WelcomeC++ to the C++ world!
		C++
		C++Welcome to the world!
		C++
		Welcome to the worldC++
		C++
		Welcome to the worldC+
		C++        
		则:out.txt
		16
		8
		1
		21
		-1
		注意：请勿改动主函数main和其它函数中的任何内容，仅在Begin和End之间填入你编写的若干语句
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include<iostream>
		#include <string.h>
		using namespace std;
		int find(char * strSrc, char * strFind)
		{
		/***************************** Begin ******************************/
		int n1=strlen(strSrc),n2=strlen(strFind) ;
		int i,j;
		if(n1<n2)
		return -1;
		for(i=0;i<n1-n2;i++)
		{
			for(j=0;j<n2;j++)
			{
				if(strSrc[i+j]==strFind[j])
				break;
			}
			if(j==n2)
			return i+1;
		}
		return -1;
		/***************************** End ********************************/
		}

		int main()
		{
			ifstream file_in("in.txt");
			ofstream file_out("out.txt"); 
			if(!file_in||!file_out) return -1;
			streambuf *std_in;  
			streambuf *std_out;
			std_in= cin.rdbuf(file_in.rdbuf());  
			std_out= cout.rdbuf(file_out.rdbuf());  

			char strSrc[100],strFind[100];
			while(cin.getline(strSrc,100)&&cin.getline(strFind,100))
				cout<<find(strSrc,strFind)<<"\n";

			file_in.close();
			file_out.close();
			cin.rdbuf(std_in); 
			cout.rdbuf(std_out);	
			return 0;
		}




103.		/*
		设计函数fun:从保存n个学生记录的stu1数组中，找出低于平均分的学生数据，并保存在sut2数组中，函数返回值表示找到的学生人数。
		学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组中。
		请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。
		-------------------------------------------------------------------------------------------------------------------------*/
		#include <iostream>
		using namespace std;
		#include<fstream>
		#include<iomanip>
		#define N 8 
		struct student
		{   
		   char num[10];
		    int score;
		};
		int fun(student stu1[],int n,student stu2[])
		{

		    /**********  Begin  **********/
		    float s=0,aver;
		    int t=0;
		for(int i=0;i<n;i++)
		{
			s+=stu1[i].score;
		 } 
		 aver=s/n;
		 for(int i=0;i<n;i++)
		 {
			if(stu1[i].score<aver)
			{
				stu2[t]=stu1[i];
				t++;
			 }
		 }
		 return t;
		    /**********   End  ***********/
		}

		int main()
		{  
			student stu1[N]={{"GA05",85},{"GA03",76},{"GA02",69},{"GA04",85},{"GA01",91},{"GA07",72},{"GA08",64},{"GA06",87}};
			student stu2[N];
			int i,n;
			n=fun(stu1,N,stu2);
			cout<<"所有学生数据："<<endl;
			for(i=0;i<N;i++)
			cout<<stu1[i].num<<setw(4)<<stu1[i].score<<endl;
		      cout<<n<<endl;	
			cout<<"低于平均分学生数据："<<endl;
			for(i=0;i<n;i++)
			cout<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;

			//结果写入out.txt 
			ofstream ofile; 
			ofile.open("out.txt");
			ofile<<n<<endl;
			for(i=0;i<n;i++)
			ofile<<stu2[i].num<<setw(4)<<stu2[i].score<<endl;
			ofile.close();
		}




104.		/*
		定义时间类Time，包括私有成员变量hour(int)、minute(int)、second(int)； 
		成员函数set_time(int h,int m,int s)将读入的3个整数规范化后给3个成员变量赋值，使得 
		second满60向minute进1，并规范化至[0,59]；minute满60向hour进1，并规范化至[0,59]；hour满24则规范化至[0,23]； 
		成员函数show_time(ofstream & output)读取3个成员变量，格式化为00:00:00形式后，输出到文件中； 
		程序中的输入文件in.txt包含以下数据：
		0 0 0
		1 59 62
		1 63 63
		2 63 59
		3 123 63
		3 126 125
		23 59 67
		26 68 61 
		输出文件out.txt包含以下数据（英文冒号）：
		00:00:00
		02:00:02
		02:04:03
		03:03:59
		05:04:03
		05:08:05
		00:00:07
		03:09:01 
		程序从文件in.txt中读取数据，输出到文件out.txt中，不可以用 cin 和 cout ； 
		只能在Begin和End之间输入代码，不能改动程序的任何其余部分。 
		---------------------------------------------------------------------------------------------------*/
		#include <fstream>
		#include <iomanip>
		using namespace std;
		ifstream infile("in.txt");
		ofstream outfile("out.txt");
		/************************* Begin ***********************/
		class Time
		{
			private:
				int hour;
				int minute;
				int second;
			public:
				void set_time(int h,int m,int s)
				{
					while(s>=60)
					{
						s-=60;m++;
					}
					while(m>=60)
					{
						m-=60;h++;
					}
					while(h>=24)
					{
						h-=24;
					}
					hour=h;minute=m;second=s;
				}
				void show_time(ofstream &output)
				{
					if(hour<10)
					output<<"0"<<hour<<":";
					else
					output<<hour<<":";
					if(minute<10)
					output<<"0"<<minute<<":";
					else
					output<<minute<<":";
					if(second<10)
					output<<"0"<<second<<endl;
					else
					output<<second<<endl;
				}

		};
		/************************* End ************************/
		int main()
		{ 
			if(!infile) return -1;
			if(!outfile) return -1;

			Time t;
			int h,m,s;
			while(!infile.eof())
			{
				infile>>h>>m>>s;
				t.set_time(h,m,s);
				t.show_time(outfile);		
			}
			infile.close();
			outfile.close();	
			return 0;
		}



105.		#include <bits/stdc++.h>
		using namespace std;
		int a[1000];
		int main()
		{
			int i,t=0;
			while(std::cin>>i)
			{
				a[i]++;
				t++;
				i=0;
			}
			cout<<t<<endl;                      //t即输入数字的个数
			for(int k=0;k<1000;k++)
			{
				if(a[k]!=0)
				{
					cout<<k<<" "<<a[k]<<endl;
				}
			} 
			return 0;
		}




106.		#include <bits/stdc++.h>
			using namespace std;
			int main()
			{
				int a=0,b=0;
				if(cin>>a)
				{	
					int t=1;
					while(cin>>b)
					{
						if(a==b)
						{
							t++;                       //即相同的数字和+1 
						}
						else
						{
							cout<<a<<" "<<t<<endl;    //输出
							t=1;
							a=b; 
						}
					}
					cout<<a<<" "<<t<<endl;
				}
				return 0;
			}






107.			#include <bits/stdc++.h>
			#include <algorithm>
			using namespace std;
			int main()
			{
				int n,m=1,a[20];
				cin>>n;
				for(int i=1;i<=n;i++)
				{
					a[i]=i;                   //存放排列中的数组 
					m*=i;                     //求得排列的总和--n! 
				}
				for(int i=1;i<=m;i++)
				{
					for(int k=1;k<=n;k++)     //输出排列 
					{
						cout<<"    "<<a[k];
					} 
					cout<<endl;
					next_permutation(a+1,a+1+n);    //下一个字典序 
				}
				return 0;
			}
			
			
			
			
			
			
			
			
			
			
108.			#include <stdlib.h>
			#include <stdio.h>
			#include <string.h>
			#include <iostream>
			#include <bits/stdc++.h>

			#define MaxListSize 20;

			#define TRUE   1
			#define FALSE  0
			#define OK     1
			#define ERROR  0
			typedef bool   Status;

			struct Student
			{
				int   id;                //学号
				char  name[10];          //姓名
				float CP;                //计算机基础
				float DS;                //数据结构
				float PG;                //程序设计
				float AV;                //平均分
			}student[MaxListSize];

			struct LinearList            //学生信息线性表
			{
				Etype  *element;
				int    len;
				int    Maxsize;
			}L;


			char re_choose[] = { "\n选择非法,请输入正确编号!\n" };                     //重选

			void Menu_name()               //1.打印作者信息函数
			{
				printf("\n\n\n\n\n\n\n");
				printf("              *************************************************\n");
				printf("                           学生成绩单的线性表顺序存储\n\n");
				printf("                           制作:小曹\n");
				printf("                           班级:2004班\n");
				printf("                           学号: 202021130162\n");
				printf("                           指导老师: 孙夫雄\n");
				printf("              **************************************************\n");
				printf("\n\n\n\t\t");
			}

			void InitWrite()                                        //2.文件读取函数
			{
				char name[10][10] = { "小张","小王","小李","小刘","小邓" };

				float CP[4] = { 100.0,80.0,90.0,60.0 };
				float DS[4] = { 98.0,90.0,88.0,70.0 };
				float PG[4] = { 99.0,85.0,89.0,65.0 };
				float AV[4] = { 99.0,85.0,89.0,65.0 };
				int id[4] = { 1000,1001,1002,1003 };
				for (int i = 0; i < 4; i++)                          //把数组中的数据放到结构体数组student中
				{
					strcpy(student[i].name,name[i]);
					student[i].CP = CP[i];
					student[i].DS = DS[i];
					student[i].PG = PG[i];
					student[i].AV = AV[i];
				}
				File* f;                                             //定义文件对"学生成绩表"进行操作
				int numwrite;
				f = open("学生成绩表.dat", "w+");
				if (f == NULL)
				{
					cout << "文件打开失败!";
					return;
				}
				for (int i = 0; i < 4; i++)
				{
					numwrite = fwrite(&student[i], sizeof(student), 1, f);       //将学生数据填入文件f中
				}
				fclose(f);
			}

			void SaveFile()                                                      //不晓得这个是干啥的
			{
				FILE* f;
				int numwrite;

				f = fopen("学生成绩表.dat", "w+");
				if (f == NULL)
				{
					printf("文件打开失败!");
					return;
				}
				for (int i = 0; i < L.length; i++)
					numwrite = fwrite(&L.element[i], sizeof(Student), 1, f);
				fclose(f);
			}
			char Name[10];                                                         //也不晓得这里是在干啥
			float CP;
			float DS;
			float PG;
			float AV;

			void Record_add(Student& record)                                       //插入学生数据功能
			{
				cout << "\n\t\t\t 输入学号";
				cin >> record.id;
				cout << "\n\t\t\t 输入姓名";
				cin >> record.name;
				cout << "\n\t\t\t 输入计算机基础成绩";
				cin >> record.CP;
				cout << "\n\t\t\t 输入数据结构成绩";
				cin >> record.DS;
				cout << "\n\t\t\t 输入程序设计成绩";
				cin >> record.PG;;
				record.AV = (record.CP + record.DS + record.PG) / 3;
			}

			void ReadRecord()
			{
				FIle* f;
				f = fopen("学生成绩表.dat", "r+");
				if (f == NULL)
				{
					printf("文件打开失败!!");
					return;
				}
				int i = 0;
				while (fread(&L.element[i], sizeof(Student), 1, f))
				{
					i++;
				}
				L.len = i;
				fclose(f)
			}

			void Create(LinearList& L, int& Maxsize)                                //构造线性表
			{
				L.Maxsize = Maxsize;
				L.element = new Student[L.Maxsize];
				L.len = 0;
			}

			bool Insert(LinearList& L, int k, Student& x)                             //在线性表L中第k个元素后插入元素x(功能)
			{
				if (k<0 || k>L.len || L.len == L.Maxsize)                             //如果不存在k或线性表已满,则返回错误
				{
					return ERROR;
				}
				for (int i = L.len - 1; i >= k; i--)
				{
					L.element[i + 1] = L.element[i];                                   //后移,给新元素腾出位置
				}
				L.element[k] = x;
				L.len++;
				return OK;
			}

			bool Delete(LinearList& L, int k)                                           //删除第k个元素(功能)
			{
				if (k<1 || k>L.len)
				{
					return ERROR;
				}
				for (int i = k; i < L.len; i++)
				{
					L.element[i - 1] = L.element[i];                                     //前移,删去指定元素
				}
				L.len--;
				return OK;
			}

			int Search(LinearList& L, unsigned& x)                                       //通过学号查找元素内容(功能)
			{
				for (int i = 0; i < L.len; i++)
				{
					if (L.element[i].id == x)
						return i;                                                        //返回位置下标
				}
				return -1;                                                               //未找到
			}

			void output(LinearList& L)                                                    //输出线性表
			{

				cout << "\n\n";
				cout << " ┌─────────────────────────────┐" << endl;
				cout << " │                      成    绩    单                      │" << endl;
				cout << " ├────┬───┬─────┬────┬────┬────┤" << endl;
				cout << " │        │      │          │        │        │        │" << endl;
				cout << " │学    号│姓 名 │计算机基础│数据结构│程序设计│平均成绩│" << endl;
				cout << " │　　　　│　　　│　　　    │　　　　│　　　　│　　　　│" << endl;
				cout << " ├────┼───┼─────┼────┼────┼────┤" << endl;

				for (int i = 0; i < L.len; i++)
				{
					cout << " │" << setw(8) << L.element[i].id << "│" << setw(6) << L.element[i].Name << "│" << setw(10) << L.element[i].CP << \
						"│ " << setw(7) << L.element[i].DS << "│" << setw(8) << L.element[i].PG << "│" << setw(8) << L.element[i].AV << "│" << endl;
					cout << " ├────┼───┼─────┼────┼────┼────┤" << endl;
				}
				cout << " │        │      │          │        │        │        │" << endl;
				cout << " └────┴───┴─────┴────┴────┴────┘" << endl;
			}

			bool Get(LinearList& L, int k, Student& x)                                    //将第k个元素存到x中
			{
				if (k<1 || k>L.len)
					return false;
				x = L.ken[k - 1];
				return true;
			}

			void Print_record(int pos)                                                   //输出某一条记录
			{
				cout << "\n\t      学生学号:" << L.element[pos].No;
				cout << "\n\t      学生姓名:" << L.element[pos].Name;
				cout << "\n\t计算机基础成绩:" << L.element[pos].CPMark;
				cout << "\n\t  数据结构成绩:" << L.element[pos].DSMark;
				cout << "\n\t  程序设计成绩:" << L.element[pos].PGMark;
				cout << "\n\t  程序设计成绩:" << L.element[pos].PGMark;
				cout << "\n\t      平均成绩:" << L.element[pos].Average;
				cout << endl;
			}

			void Chance(char j)                                                            //操作选择函数
			{
				unsigned k;
				int pos;
				Student x;
				switch (j)
				{
				case'1':                                                                   //1.显示线性表中的元素
					system("cls");
					output(L);
					system("pause");
					system("cls");
					break;
				case'2':                                                                   //2.插入元素
					system("cls");
					output(L);
					cout << "\n\t当前下标范围:0--" << L.len << endl;
					cout << "\n\t请输入要插入点的下标:";
					cin << k;
					fflush(stdin);
					if (k<0 || k>L.len)
					{
						cout << "\n" << re_choose << endl;
						system("pause");
						system("cls");
						break;
					}
					Record_add(x);                                                          //制造一个要插入的元素
					if (Insert(L, k, x))                                                    //插入操作
					{
						cout << "插入成功!!\n\n";
						output(L);
						SaveFile();
					}
					else
						cout << "插入失败!!";
					system("pause");
					system("cls");
					break;
				case'3':                                                                   //3.删除线性表中的元素
					system("cls");
					output(L);
					cout << "\n\t当前下标范围:0--" << L.len << endl;
					cout << "\n\t请输入要删除点的下标:";
					cin << k;
					fflush(stdin);
					if (k<0 || k>L.len)
					{
						cout << "\n" << re_choose << endl;
						system("pause");
						system("cls");
						break;
					}
					if (Delete(L, k))
					{
						cout << "删除成功!!\n\n";
						output(L);
						SaveFile();
					}
					else
						cout << "删除失败!!\n\n";
					system("pause");
					system("cls");
					break;
				case'4':                                                                   //4.查找线性表中的元素
					system("cls");
					output(L);
					cout << "\n\t输入要查找的学生学号:";
					cin << k;
					fflush(stdin);
					pos = Search(L, k);                                                    //返回下标或-1
					if (pos >= 0)                                                             
					{
						cout << "查找成功!!\n\n";
						Print_record(pos);
					}
					else
						cout << "查找失败!!\n\n";
					system("pause");
					system("cls");
					break;
				case'5':                                                                   //5.输出线性表中第k个元素
					output(L);
					cout << "\n\t当前下标范围:0--" << L.len << endl;
					cout << "\n\t请输入要取出元素的下标:";
					cin << k;
					fflush(stdin);
					if (k<0 || k>L.len)
					{
						cout << "\n" << re_choose << endl;
						system("pause");
						system("cls");
						break;
					}
					if (Get(L, k, x))
					{
						cout << "取出成功!!\n\n";
						Print_record(k - 1);
					}
					else
						cout << "取出失败!!\n\n";
					system("pause");
					system("cls");
					break;
				case'0':                                                                   //0.退出操作
					exit(0);
					break;
				default:
					cout << re_choose << endl;
					system("pause");
					system("cls");
					break;
				}
			}

			void Menu()                                                                      //菜单函数
			{
				cout << "\n\t\t" << "请选择以下一个功能:" << endl;
				cout << "\n\t\t" << "1.显示线性表中的数据元素." << endl;
				cout << "\t\t2.插入数据元素." << endl;
				cout << "\t\t3.删除数据元素." << endl;
				cout << "\t\t4.查找数据元素." << endl;
				cout << "\t\t5.取第k个元素 " << endl;
				cout << "\t\t0.退出.\n" << endl;
				cout << "\t\t===============================\n" << endl;
			}

			int main()
			{
				char j;
				char a[100];
				Menu_name();
				system("pause");
				system("cls");
				int Maxsize = MaxListSize;
				Create(L, Maxsize);
				ReadRecord();
				while (1)
				{
					system("cls");
					Menu();
					cout << "\n\t输入功能编号:";
					cin << a;
					if (a[i] != '\0')
					{
						cout << "\n" << re_choose << endl;
						system("pause");
						system("cls");
						continue;
					}
					else
					{
						if (a[0] == '0')
							break;
						else
							Chance(a[0]);
					}
				}
				return 0;
			}



109.			#pragma once
			#define HEADSTUDENT HeadType              //!!!!宏相当于替换,即用一个标识符来替换字符串,如果后面的代码中出现该标识符,全部视为指定字符串
			#define STUDENT ElementType               //例如:如果后续出现STUDENT,处理器会将其视为ElementType
			#define age key                           //宏定义:    #define 宏名 字符串

			class HEADSUDENT
			{
			public:
				char nameclass[20];
				int number;
				char place[20];
			};
			class STUDENT
			{
			public:
				char number[8];
				char sex[3];
				int age;
			};





110.			#pragma once
			template <class ElementType>                                 //1.定义数据元素结点
			class SimpleChainNode
			{
			public:
				ElementType data;                                        //数据域:结点中储存的数据类型为ElementType
				SimpleChainNode<ElementType>* link;                      //指针域:指向下一个元素
			};

			template <class HeadType,class ElementType>                  //2.定义头结点
			class SimpleHeadNode
			{
			public:
				HeadType Hdata;                                          //数据域:结点中储存的数据类型为HeadType
				SimpleChainNode<ElementType>* first;                     //指针域:指向第一个结点
			};


			//-------------------------元素定义完毕,开始定义简单链表模板类SimpleChainList-------------------------//
			template <class HeadType,class ElementType>
			class SimpleChainList
			{
			private:
				PutSimpleHeadNode<HeadType>* HeadPtr;                     //定义头结点指针
			public:
				SimpleChainList();                                        //构造函数
				~SimpleChianList();                                       //析构函数
				int LengthSimpleChainList();                              //表长函数
				void PutSimpleHeadNode(HeadType& head)                    //已知值head,给头结点赋值
				{HeadPtr->Hdata = head;}
				SimpleHeadNode<HeadType>* GetHeadPtrSimpleChainList()     //返回头结点指针
				{return HeadPtr;}
				SimpleChainNode<ElementType>* GetFirstPtrSimpleChainList()//返回第一个结点指针
				{return HeadPtr->first;}

				//1.查找函数
					// ①查找第k个元素,存入result中
				bool GetElementSimpleChainList(int k, ElementType& result);
					// ②查找current指向的元素,存入result中
				bool GetElementSimpleChainList(SimpleChainNode<ElementType>* current, ElementType& result);
					// ③查找关键字(key1)值为searchkey(字符型)的元素,返回元素指针(在AppData中有宏定义了key,其中key1=name,key2=age)
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(char searchkey);
					// ④查找关键字(key2)值为searchkey(数值型)的元素,返回元素指针
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(int searchkey);

				//2.插入函数
					// ①插入值为newvalue的元素到链表第k个元素的后面
				bool InsertElementSimpleChainList(int k, ElementType& newvalue);
					// ②插入值为newvalue的元素到InsertPtr指针所指的元素的前面
				bool InsertElementSimpleChainList(SimpleChainNode<ElementType>* InsertPtr, ElementType& newvalue);

				//3.删除函数
					// ①删除第k个元素
				bool DeleteElementSimpleChainList(int k);
					// ②删除DeletePtr指针所指的元素
				bool DeleteElementSimpleChainList(SimpleChainNode<ElementType>* DeletePtr);

				//4.应用函数
					// ①删除元素和空间,只保留表头结点
				void DestoryElementSimpleChainList();
					// ②输出元素
				void DisplayElementSimpleChainList();
					// ③输出链表
				void DisplaySimpleChainList();
			};





111.			#pragma once
			template <class ElementType>                                 //1.定义数据元素结点
			class SimpleChainNode
			{
			public:
				ElementType data;                                        //数据域:结点中储存的数据类型为ElementType
				SimpleChainNode<ElementType>* link;                      //指针域:指向下一个元素
			};

			template <class HeadType,class ElementType>                  //2.定义头结点
			class SimpleHeadNode
			{
			public:
				HeadType Hdata;                                          //数据域:结点中储存的数据类型为HeadType
				SimpleChainNode<ElementType>* first;                     //指针域:指向第一个结点
			};


			//-------------------------元素定义完毕,开始定义简单链表模板类SimpleChainList-------------------------//
			template <class HeadType,class ElementType>
			class SimpleChainList
			{
			private:
				PutSimpleHeadNode<HeadType>* HeadPtr;                     //定义头结点指针
			public:
				SimpleChainList();                                        //构造函数
				~SimpleChianList();                                       //析构函数
				int LengthSimpleChainList() const;                        //表长函数
				void PutSimpleHeadNode(HeadType& head)                    //已知值head,给头结点赋值
				{HeadPtr->Hdata = head;}
				SimpleHeadNode<HeadType>* GetHeadPtrSimpleChainList()     //返回头结点指针
				{return HeadPtr;}
				SimpleChainNode<ElementType>* GetFirstPtrSimpleChainList()//返回第一个结点指针
				{return HeadPtr->first;}

				//1.查找函数
					// ①查找第k个元素,存入result中
				bool GetElementSimpleChainList(int k, ElementType& result);
					// ②查找current指向的元素,存入result中
				bool GetElementSimpleChainList(SimpleChainNode<ElementType>* current, ElementType& result);
					// ③查找关键字(key1)值为searchkey(字符型)的元素,返回元素指针(在AppData中有宏定义了key,其中key1=name,key2=age)
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(char searchkey);
					// ④查找关键字(key2)值为searchkey(数值型)的元素,返回元素指针
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(int searchkey);

				//2.插入函数
					// ①插入值为newvalue的元素到链表第k个元素的后面
				bool InsertElementSimpleChainList(int k, ElementType& newvalue);
					// ②插入值为newvalue的元素到InsertPtr指针所指的元素的前面
				bool InsertElementSimpleChainList(SimpleChainNode<ElementType>* InsertPtr, ElementType& newvalue);

				//3.删除函数
					// ①删除第k个元素
				bool DeleteElementSimpleChainList(int k);
					// ②删除DeletePtr指针所指的元素
				bool DeleteElementSimpleChainList(SimpleChainNode<ElementType>* DeletePtr);

				//4.应用函数
					// ①删除元素和空间,只保留表头结点
				void DestoryElementSimpleChainList();
					// ②输出元素
				void DisplayElementSimpleChainList();
					// ③输出链表
				void DisplaySimpleChainList();
			};

			template <class HeadType,class ElementType>                   //-----1.构造函数
			SimpleChainList<HeadType,ElementType>::
			SimpleChainList()                                              
			{
				HeadPtr = new SimpleHeadNode<HeadType>;
				HeadPtr->first = NULL;                                    //头插法
			}

			template <class HeadType,class ElementType>                   //-----2.析构函数:释放空间
			SimpleChainList<HeadType,ElementType>::
			SimpleChainList()                                              
			{
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				while (HeadPtr->first)
				{ 
					current = current->link;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template <class HeadType,class ElementType>                     //-----3.表长函数
			int SimpleChainList<HeadType,ElementType>::
			LengthSimpleChainList() const                                 
			{
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int len = 0;
				while (current)
				{
					len++;
					current = current->link;
				}
				return len;
			}

			template <class HeadType,class ElementType>                      //-----4.①查找第k个元素
			bool SimpleChainList<HeadType,ElementType>::
			GetElementSimpleChainList(int k, ElementType& result)          
			{
				if (k < 1)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int i = 1;
				while (i < k && current)
				{
					current = current->link;
					i++;
				}
				if (current)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			template <class HeadType,class ElementType>                       //-----4.②查找current指向的元素
			bool SimpleChainList<HeadType,ElementType>::
			GetElementSimpleChainList(SimpleChainNode<ElementType>* current, ElementType& result)
			{
				if (!current)
					return false;
				result = current->data;
				return true;
			}

			template <class HeadType,class ElementType>                       //-----4.③查找key为searchkey(字符型)的元素 (即name)
			SimpleChainNode<ElementType> *SimpleChainList<HeadType,ElementType>::
			SearchElementSimpleChainList(char searchkey)
			{
				SimpleChainNode<ElementType>* current;
				while (current && strcmp(searchkey, current->data.key1))
				{
					current = current->link;
				}
				if (current)
				{
					return current;
				}
				return NULL;
			}

			template <class HeadType,class ElementType>                         //-----4.④查找key为searchkey(数值型)的元素 (即age)
			SimpleChainNode<ElementType> *SimpleChainList<HeadType,ElementType>::
			SearchElementSimpleChainList(int searchkey)
			{
				SimpleChainNode<ElementType>* current;
				while (current)
				{
					if (current->data.key2 == searchkey)
						break;
					current = current->link;
				}
				if (current)
				{
					return current;
				}
				return NULL;
			}

			template <class HeadType,class ElementType>                         //-----5.①插入newvalue元素到第k个元素之后
			bool SimpleChainList<HeadType,ElementType>::
			InsertElementSimpleChainList(int k, ElementType& newvalue)
			{
				if (k < 0)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int i = 0;
				while (i < k && current)                                         //找到第k个结点,current此时指向k
				{
					current = current->link;
					i++;
				}
				if (k > 0 && !current)
					return false;                                                //第一种情况:current指向NULL,无法插入,返回false
				SimpleChainNode<ElementType>* p = new SimpleChainNode<ElementType>;
				p->data = newvalue;
				if (k)                                                           //第二种情况:current指向链表中的普通结点,将p结点插入即可
				{
					p->link = current->link;
					current->link = p;
				}
				else                                                             //第三种情况:current指向头结点,将p结点换成第一个结点即可
				{
					p->link = HeadPtr->first;
					HeadPtr->first = p;
				}
				return true;
			}

			template <class HeadType,class ElementType>                          //-----5.②在InsertPtr指针所指的元素前插入newvalue元素
			bool SimpleChainList<HeadType,ElementType>::
			InsertElementSimpleChainList(SimpleChainNode<ElementType>* InsertPtr, ElementType& newvalue)
			{
				if (!InsertPtr)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				if (InsertPtr != HeadPtr->first)                                 //第一种情况:InsertPtr不是第一个结点的指针
				{
					while (current && current->link != InsertPtr)                //找到InsertPtr指针的前一个结点
					{
						current = current->link;
					}
					if (!current)
						return false;
				}
				SimpleChainNode<ElementType>* p = new SimpleChainNode<ElementType>;
				p->data = newvalue;
				if (InsertPtr == HeadPtr->first)                                 //第二种情况:InsertPtr是第一个结点的指针
				{
					p->link = HeadPtr->first;
					HeadPtr->first = p;
				}
				else
				{
					p->link = current->link;
					current->link = p;
				}
				return true;
			}

			template <class HeadType,class ElementType>                          //6.①删除第k个元素
			bool SimpleChainList<HeadType,ElementType>::
			DeleteElementSimpleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				if (k == 1)                                                      //第一种情况:删除第一个结点
				{
					HeadPtr = current->link;  
					return true;
				}
				else                                                             //第二种情况:删除普通结点
				{
					SimpleChainNode<ElementType>* p = HeadPtr->first;
					int i = 1;
					while (i < k - 1 && current)                                 //找到第k-1个结点
					{
						current = current->link;
						i++;
					}
					if (!current || !current->link)                              //如果为NULL,返回false
						return false;
					else
					{
						p = current->link;                                       //p指向第k个结点
						current->link = p->link;
					}
					delete p;
					return true;
				}
			}

			template <class HeadType,class ElementType>                          //6.②删除DeletePtr指针指向的元素
			bool SimpleChainList<HeadType,ElementType>::
			DeleteElementSimpleChainList(SimpleChainNode<ElementType>* DeletePtr)
			{
				if (!DeletePtr)
					return false;
				else if (DeletePtr == HeadPtr->first)
				{
					HeadPtr->first = DeletePtr->link;
					return true;
				}
				else
				{
					SimpleChianNode<ElementType>* current;
					current = HeadPtr->first;
					while (current && current->link != DeletePtr)                //找到DeletePtr指针的前一个结点
					{
						current = current->link;
					}
					if (!current)
						return false;
					current->link = DeletePtr->link;
					delete DeletePtr;
					return true;
				}
			}










112.			#pragma once
			template <class ElementType>                                 //1.定义数据元素结点
			class SimpleChainNode
			{
			public:
				ElementType data;                                        //数据域:结点中储存的数据类型为ElementType
				SimpleChainNode<ElementType>* link;                      //指针域:指向下一个元素
			};

			template <class HeadType,class ElementType>                  //2.定义头结点
			class SimpleHeadNode
			{
			public:
				HeadType Hdata;                                          //数据域:结点中储存的数据类型为HeadType
				SimpleChainNode<ElementType>* first;                     //指针域:指向第一个结点
			};


			//-------------------------元素定义完毕,开始定义简单链表模板类SimpleChainList-------------------------//
			template <class HeadType,class ElementType>
			class SimpleChainList
			{
			private:
				PutSimpleHeadNode<HeadType>* HeadPtr;                     //定义头结点指针
			public:
				SimpleChainList();                                        //构造函数
				~SimpleChianList();                                       //析构函数
				int LengthSimpleChainList() const;                        //表长函数
				void PutSimpleHeadNode(HeadType& head)                    //已知值head,给头结点赋值
				{HeadPtr->Hdata = head;}
				SimpleHeadNode<HeadType>* GetHeadPtrSimpleChainList()     //返回头结点指针
				{return HeadPtr;}
				SimpleChainNode<ElementType>* GetFirstPtrSimpleChainList()//返回第一个结点指针
				{return HeadPtr->first;}

				//1.查找函数
					// ①查找第k个元素,存入result中
				bool GetElementSimpleChainList(int k, ElementType& result);
					// ②查找current指向的元素,存入result中
				bool GetElementSimpleChainList(SimpleChainNode<ElementType>* current, ElementType& result);
					// ③查找关键字(key1)值为searchkey(字符型)的元素,返回元素指针(在AppData中有宏定义了key,其中key1=name,key2=age)
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(char searchkey);
					// ④查找关键字(key2)值为searchkey(数值型)的元素,返回元素指针
				SimpleChainNode<ElementType>* SearchElementSimpleChainList(int searchkey);

				//2.插入函数
					// ①插入值为newvalue的元素到链表第k个元素的后面
				bool InsertElementSimpleChainList(int k, ElementType& newvalue);
					// ②插入值为newvalue的元素到InsertPtr指针所指的元素的前面
				bool InsertElementSimpleChainList(SimpleChainNode<ElementType>* InsertPtr, ElementType& newvalue);

				//3.删除函数
					// ①删除第k个元素
				bool DeleteElementSimpleChainList(int k);
					// ②删除DeletePtr指针所指的元素
				bool DeleteElementSimpleChainList(SimpleChainNode<ElementType>* DeletePtr);

				//4.应用函数
					// ①删除元素和空间,只保留表头结点
				void DestoryElementSimpleChainList();
					// ②输出元素
				void DisplayElementSimpleChainList(ElementType result);
					// ③输出链表
				void DisplaySimpleChainList(SimpleChainList<HeadType,ElementType> &AppList);
			};

			template <class HeadType,class ElementType>                   //-----1.构造函数
			SimpleChainList<HeadType,ElementType>::
			SimpleChainList()                                              
			{
				HeadPtr = new SimpleHeadNode<HeadType>;
				HeadPtr->first = NULL;                                    //头插法
			}

			template <class HeadType,class ElementType>                   //-----2.析构函数:释放空间
			SimpleChainList<HeadType,ElementType>::
			SimpleChainList()                                              
			{
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				while (HeadPtr->first)
				{ 
					current = current->link;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template <class HeadType,class ElementType>                     //-----3.表长函数
			int SimpleChainList<HeadType,ElementType>::
			LengthSimpleChainList() const                                 
			{
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int len = 0;
				while (current)
				{
					len++;
					current = current->link;
				}
				return len;
			}

			template <class HeadType,class ElementType>                      //-----4.①查找第k个元素
			bool SimpleChainList<HeadType,ElementType>::
			GetElementSimpleChainList(int k, ElementType& result)          
			{
				if (k < 1)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int i = 1;
				while (i < k && current)
				{
					current = current->link;
					i++;
				}
				if (current)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			template <class HeadType,class ElementType>                       //-----4.②查找current指向的元素
			bool SimpleChainList<HeadType,ElementType>::
			GetElementSimpleChainList(SimpleChainNode<ElementType>* current, ElementType& result)
			{
				if (!current)
					return false;
				result = current->data;
				return true;
			}

			template <class HeadType,class ElementType>                       //-----4.③查找key为searchkey(字符型)的元素 (即name)
			SimpleChainNode<ElementType> *SimpleChainList<HeadType,ElementType>::
			SearchElementSimpleChainList(char searchkey)
			{
				SimpleChainNode<ElementType>* current;
				while (current && strcmp(searchkey, current->data.key1))
				{
					current = current->link;
				}
				if (current)
				{
					return current;
				}
				return NULL;
			}

			template <class HeadType,class ElementType>                         //-----4.④查找key为searchkey(数值型)的元素 (即age)
			SimpleChainNode<ElementType> *SimpleChainList<HeadType,ElementType>::
			SearchElementSimpleChainList(int searchkey)
			{
				SimpleChainNode<ElementType>* current;
				while (current)
				{
					if (current->data.key2 == searchkey)
						break;
					current = current->link;
				}
				if (current)
				{
					return current;
				}
				return NULL;
			}

			template <class HeadType,class ElementType>                         //-----5.①插入newvalue元素到第k个元素之后
			bool SimpleChainList<HeadType,ElementType>::
			InsertElementSimpleChainList(int k, ElementType& newvalue)
			{
				if (k < 0)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				int i = 0;
				while (i < k && current)                                         //找到第k个结点,current此时指向k
				{
					current = current->link;
					i++;
				}
				if (k > 0 && !current)
					return false;                                                //第一种情况:current指向NULL,无法插入,返回false
				SimpleChainNode<ElementType>* p = new SimpleChainNode<ElementType>;
				p->data = newvalue;
				if (k)                                                           //第二种情况:current指向链表中的普通结点,将p结点插入即可
				{
					p->link = current->link;
					current->link = p;
				}
				else                                                             //第三种情况:current指向头结点,将p结点换成第一个结点即可
				{
					p->link = HeadPtr->first;
					HeadPtr->first = p;
				}
				return true;
			}

			template <class HeadType,class ElementType>                          //-----5.②在InsertPtr指针所指的元素前插入newvalue元素
			bool SimpleChainList<HeadType,ElementType>::
			InsertElementSimpleChainList(SimpleChainNode<ElementType>* InsertPtr, ElementType& newvalue)
			{
				if (!InsertPtr)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				if (InsertPtr != HeadPtr->first)                                 //第一种情况:InsertPtr不是第一个结点的指针
				{
					while (current && current->link != InsertPtr)                //找到InsertPtr指针的前一个结点
					{
						current = current->link;
					}
					if (!current)
						return false;
				}
				SimpleChainNode<ElementType>* p = new SimpleChainNode<ElementType>;
				p->data = newvalue;
				if (InsertPtr == HeadPtr->first)                                 //第二种情况:InsertPtr是第一个结点的指针
				{
					p->link = HeadPtr->first;
					HeadPtr->first = p;
				}
				else
				{
					p->link = current->link;
					current->link = p;
				}
				return true;
			}

			template <class HeadType,class ElementType>                          //6.①删除第k个元素
			bool SimpleChainList<HeadType,ElementType>::
			DeleteElementSimpleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				SimpleChainNode<ElementType>* current;
				current = HeadPtr->first;
				if (k == 1)                                                      //第一种情况:删除第一个结点
				{
					HeadPtr = current->link;  
					return true;
				}
				else                                                             //第二种情况:删除普通结点
				{
					SimpleChainNode<ElementType>* p = HeadPtr->first;
					int i = 1;
					while (i < k - 1 && current)                                 //找到第k-1个结点
					{
						current = current->link;
						i++;
					}
					if (!current || !current->link)                              //如果为NULL,返回false
						return false;
					else
					{
						p = current->link;                                       //p指向第k个结点
						current->link = p->link;
					}
					delete p;
					return true;
				}
			}

			template <class HeadType,class ElementType>                          //6.②删除DeletePtr指针指向的元素
			bool SimpleChainList<HeadType,ElementType>::
			DeleteElementSimpleChainList(SimpleChainNode<ElementType>* DeletePtr)
			{
				if (!DeletePtr)
					return false;
				else if (DeletePtr == HeadPtr->first)
				{
					HeadPtr->first = DeletePtr->link;
					return true;
				}
				else
				{
					SimpleChianNode<ElementType>* current;
					current = HeadPtr->first;
					while (current && current->link != DeletePtr)                //找到DeletePtr指针的前一个结点
					{
						current = current->link;
					}
					if (!current)
						return false;
					current->link = DeletePtr->link;
					delete DeletePtr;
					return true;
				}
			}

			template <class HeadType,class ElementType>                         //输出元素
			void SimpleChainList<HeadType,ElementType>::
			DisplayElementSimpleChainList(ElementType result)
			{
				cout << result.number << "     ";
				cout << result.name << "     ";
				cout << result.sex << "     ";
				cout << result.age << endl;
			}

			template <class HeadType,class ElementType>                         //输出链表
			void SimpleChainList<HeadType,ElementType>::
			DisplaySimpleChainList(SimpleChainList<HeadType, ElementType>& AppList)
			{
				SimpleHeadNode<HeadType>* HeadPtr;
				SimpleChainNode<ElementType>* current;
				HeadPtr = AppList.GetHeadPtrSimpleChainList();
				current = HeadPtr->first;

				cout << "----------表头信息----------" << endl;
				cout << "班级        人数        教室" << endl;
				cout << HeadPtr->Hdata.nameclass << '\t\t';
				cout << HeadPtr->Hdata.number << '\t\t';
				cout << HeadPtr->Hdata.place << endl;
				cout << "---------------------------" << endl;
				cout << endl << endl << endl << endl;


				cout << "学号" << '\t\t';
				while (current)
				{
					cout << current->data.number << '\t';
					current = current->link;
				}
				cout << endl;
				current = HeadPtr->first;

				cout << "姓名" << '\t\t';
				while (current)
				{
					cout << current->data.name << '\t';
					current = current->link;
				}
				cout << endl;
				current = HeadPtr->first;

				cout << "性别" << '\t\t';
				while (current)
				{
					cout << current->data.sex << '\t';
					current = current->link;
				}
				cout << endl;
				current = HeadPtr->first;

				cout << "年龄" << '\t\t';
				while (current)
				{
					cout << current->data.age << '\t';
					current = current->link;
				}
				cout << endl << endl;
			}









113.			#include <iostream>
			#include <cstring>
			#include <stdlib.h>
			#include "AppData.h"
			#include "SimpleChainList.h"
			using namespace std;
			int main()
			{
				SimpleChainNode<ElementType>* current;
				SimpleHeadNode<HeadType>* HeadPtr;
				ElementType newvalue, result;
				int k, choice;
				HeadType Class = { "信息2004",40,"文泽212" };
				char number[][8] = { "","1001","1002","1003","1004","1005","1006","1007","1008" };
				char name[][8] = { "","1号","2号","3号","4号","5号","6号","7号","8号" };
				char sex[][8] = { "","男","女","女","女","男","女","女","男" };
				int age[] = { 0,18,19,18,20,23,24,22,21 };

				SimpleChainList<HeadType, ElementType> AppList;
				HeadPtr = AppList.GetHeadPtrSimpleChainList();
				AppList.PutSimpleHeadNode(Class);
				for (int i = 8; i >= 1; i--)
				{
					strcpy(newvalue.number, number[i]);
					strcpy(newvalue.name, name[i]);
					strcpy(newvalue.sex, sex[i]);
					newvalue.age = age[i];
					AppList.InsertElementSimpleChainList(0, newvalue);
				}
				while (1)
				{
					cout << "            简单链表存储"<< endl;
					cout << "_________________________________________" << endl;
					cout << "0----------退出" << endl;
					cout << "1----------显示表长" << endl;
					cout << "2----------查找第k元素" << endl;
					cout << "3----------查找关键字为searchkey的元素" << endl;
					cout << "4----------在第k个结点后插入元素" << endl;
					cout << "5----------删除第k元素" << endl;
					cout << "6----------显示链表元素" << endl;
					cout << "_________________________________________" << endl;
					cout << "请选择功能:" << endl;
					cin >> choice;
					system("cls");

					switch (choice)
					{
					case 0:
					{
						system("cls");
						return 0;
					}
					case 1:
					{
						cout<<"表长:"<<AppList.LengthSimpleChainList()<<endl;
						break;
					}
					case 2:
					{
						cout << "请输入序号:" << endl;
						cin >> k;
						cout << "查找结果如下:" << endl;
						if (AppList.GetElementSimpleChainList(k, result))
						{
							AppList.DisplayElementSimpleChainList(result);
						}
						else
							cout << "查找失败!!";
						break;
					}
					case 3:
					{
						int searchkey;
						cout << "请输入searchkey:" << endl;
						cin >> searchkey;
						current = AppList.SearchElementSimpleChainList(searchkey);
						cout << "查找结果如下:" << endl;
						if (current)
						{
							AppList.GetElementSimpleChainList(current , result);
							AppList.DisplayElementSimpleChainList(result);
						}
						else
							cout << "查找失败!!";
						break;
					}
					case 4:
					{
						cout << "请输入插入序号:" << endl;
						cin >> k;
						cout << "请输入元素数据:" << endl;
						cout << "            学号:" ;
						cin>>newvalue.number;
						cout<<endl;
						cout << "            姓名:" ;
						cin>>newvalue.name;
						cout<<endl;
						cout << "            性别:" ;
						cin>>newvalue.sex;
						cout<<endl;
						cout << "            年龄:" ;
						cin>>newvalue.age;
						cout<<endl;
						if (AppList.InsertElementSimpleChainList(k, newvalue))
						{
							cout << "插入后结果如下:" << endl;
							AppList.DisplaySimpleChainList(AppList);
						}
						else
							cout << "插入失败!!";
						break;
					}
					case 5:
					{
						cout << "请输入删除序号:" << endl;
						cin >> k;
						if (AppList.DeleteElementSimpleChainList(k))
						{
							cout << "删除后结果如下:" << endl;
							AppList.DisplaySimpleChainList(AppList);
						}
						else
							cout << "删除失败!!";
						break;
					}
					case 6:
					{
						cout << "链表如下:" << endl;
						AppList.DisplaySimpleChainList(AppList);
						break;
					}
					}
					cout<<endl<<endl;
					system("pause");
					system("cls");
				}
				return 0;
			}











114.			#pragma once
			template<class ElementType>
			class DoubleChainNode
			{
			public:
				ElementType data;
				DoubleChainNode<ElementType>* prelink;                                         //前驱结点
				DoubleChainNode<ElementType>* nextlink;                                        //后继结点
			};

			template<class HeadType>
			class DoubleHeadNode
			{
			public:
				HeadType Hdata;
				DoubleChainNode<ElementType>* first;
			};

			template<class HeadType,class ElementType>
			class DoubleChainList
			{
			public:
				DoubleChainList();                                                           //构造函数
				~DoubleChainList();                                                          //析构函数
				int LengthDoubleChainList();                                                 //表长函数
				void DestroyElementsDoubleChainList();                                       //删除表中元素,只留下表头
				void PutValueDoubleHeadNode(HeadType& head)                                  //将数据放入表头
				{HeadPtr->Hdata = head};
				DoubleHeadNode<HeadType>* GetHeadPtrDoubleChianList()                        //获取表头指针
				{return HeadPtr;}
				DoubleChainNode<ElementType>* GetFirstPtrDoubleChainList()                   //获取第一个结点指针
				{return HeadPtr->first;}
				bool GetElementDoubleChainList(int k, ElementType& result);                  //1.查找函数
				bool GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result);
				DoubleChainNode<ElementType>* SearchElementDoubleChainList(int searchkey);   
				bool InsertElementDoubleChainList(int k, ElementType& newvalue);             //2.插入函数
				bool DeleteElementDoubleChainList(int k);                                    //3.删除函数
			private:
				DoubleHeadNode<HeadType>* HeadPtr;
			};






115.			#pragma once
			template<class ElementType>
			class DoubleChainNode
			{
			public:
				ElementType data;
				DoubleChainNode<ElementType>* prelink;                                         //前驱结点
				DoubleChainNode<ElementType>* nextlink;                                        //后继结点
			};

			template<class HeadType>
			class DoubleHeadNode
			{
			public:
				HeadType Hdata;
				DoubleChainNode<ElementType>* first;
			};

			template<class HeadType,class ElementType>
			class DoubleChainList
			{
			public:
				DoubleChainList();                                                           //构造函数
				~DoubleChainList();                                                          //析构函数
				int LengthDoubleChainList();                                                 //表长函数
				void DestroyElementsDoubleChainList();                                       //删除表中元素,只留下表头
				void PutValueDoubleHeadNode(HeadType& head)                                  //将数据放入表头
				{HeadPtr->Hdata = head};
				DoubleHeadNode<HeadType>* GetHeadPtrDoubleChianList()                        //获取表头指针
				{return HeadPtr;}
				DoubleChainNode<ElementType>* GetFirstPtrDoubleChainList()                   //获取第一个结点指针
				{return HeadPtr->first;}
				bool GetElementDoubleChainList(int k, ElementType& result);                  //1.查找函数
				bool GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result);
				DoubleChainNode<ElementType>* SearchElementDoubleChainList(int searchkey);   
				bool InsertElementDoubleChainList(int k, ElementType& newvalue);             //2.插入函数
				bool DeleteElementDoubleChainList(int k);                                    //3.删除函数
			private:
				DoubleHeadNode<HeadType>* HeadPtr;
			};



			/*主要理解点:对于前后指针域的修改,一共有四个,插入newvalue的prelink,nextlink,第k个元素的nextlink,第k+1个元素的prelink(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			InsertElementDoubleChainList(int k, ElementType &newvalue)
			{
				if (k < 0)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)                                                     //指向第k个结点
				{
					current = current->nextlink;
					i++;
				}
				if (k > 0 && current == NULL)
					return false;
				DoubleChainNode<ElementType>* p = new DoubleChainNode<ElementType>;
				p->data = newvalue;
				if (k != 0)
				{
					p->nextlink = current->nextlink;                                         //注意理解两个指针(pre和next),课本P47,即前后结点都会与newvalue产生联系,要对他们的结点都进行修改
					p->prelink = current;
					DoubleChainNode<ElementType>* q = current->nextlink;                     //q指向第k+1个结点,该结点的prelink指向newvalue(新插入的结点)
					if (q)                                                                   //如果q为NULL,就不用修改prelink了
					{
						q->prelink = p;
					}
					current->nextlink = p;
				}
				else                                                                         //此时k==0,作为第一个结点插入
				{
					p->nextlink = HeadPtr->first;
					p->prelink = HeadPtr;
					DoubleChainNode<ElementType>* q = HeadPtr->first;
					if (q)                                                                 
					{
						q->prelink = p;
					}
					HeadPtr->first = p;
				}
				return true;
			}

			/*主要理解点:一般要修改第k-1个结点的nextlink和第k+1个结点的prelink,来删除第k个结点(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			DeleteElementDoubleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;                      //current用来指向第k-1个结点,帮助修改nextlink
				DoubleChainList<ElementType>* p;                                             //p用来指向第k+1个结点,帮助修改prelink
				if (k == 1)
				{
					p = current->nextlink;
					if (p)                                                                   //在p非空时,其prelink还是要修改的
					{
						p->prelink = HeadPtr;
					}
					HeadPtr->first = p;
				}
				else
				{
					int i = 0;
					while (i < k - 1)                                                        //将current指向第k-1个结点
					{
						current = current->nextlink;
					}
					if (!current||!current->nextlink)                      
					{
						return false;
					}
					else
					{
						DoubleChainNode<ElementType>* q = current->nextlink;                  //q指向第k个结点
						p = q->nextlink;                                                      //p指向第k+1个结点
						current->nextlink = p;
						if (p)
						{
							p->prelink = current;
						}	
					}
				}
				delete current;
				return true;
			}

			//还有查找操作为定义





116.			#pragma once

			/*循环单链表*/
			template<class ElementType>
			class LoopChainNode
			{
			public:
				ElementType data;
				LoopChainNode<ElementType>* link;
			};

			template<class HeadType>
			class LoopHeadNode
			{
			public:
				HeadType Hdata;
				LoopHeadNode<HeadType>* first;
			};

			template<class HeadType,class ElementType>
			class LoopChainList
			{
			public:
				LoopChainList();                                                  //构造函数
				~LoopChainList();                                                 //析构函数
				int LengthChainList();                                            //表长函数
				void DestoryElementChainList();                                   //删除结点
				void PutValueChainList(HeadType& value)                           //输入头结点
				{HeadPtr->Hdata = value;};
				LoopHeadNode<HeadType>* GetHeadPtrChainList()                     //获取头指针
				{return HeadPtr;};
				LoopChainNode<ElementType>* GetFirstPtrChainList()                //获取第一个结点指针
				{return HeadPtr->first;};
				bool GetElementChainList(int k,ElementType &result);              //1.查找函数
				bool GetElementChainList(LoopChainNode<ElementType>* p, ElementType& result);
				LoopChainNode<ElementType>* SearchElementChainList(int searchkey);
				bool InsertElementChainList(int k, ElementType& newvalue);        //2.插入函数
				bool DeleteElementChainList(int k);                               //3.删除函数
			private:
				LoopHeadNode<HeadType>* HeadPtr;
			};


			template<class HeadType,class ElementType>                            //一.构造函数
			LoopChainList<HeadType, ElementType>::
			LoopChainList()
			{
				HeadPtr = new LoopHeadNode<HeadType>;
				HeadPtr->first = NULL;
			}

			template<class HeadType,class ElementType>                            //二.析构函数
			LoopChainList<HeadType, ElementType>::
			~LoopChainList()
			{
				LoopChainNode<ElementType>* current = HeadPtr->first;
				while (HeadPtr->first)
				{
					current = current->link;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template<class HeadType,class ElementType>                            //三.表长函数
			int LoopChainList<HeadType, ElementType>::
			LengthChainList()
			{
				LoopChainNode<ElementType>* current = HeadPtr->first;
				int len = 0;
				while (current->link != HeadPtr->first)
				{
					len++;
					current = current->link;
				}
				return len;
			}

			template<class HeadType,class ElementType>                            //四.查找函数1
			bool LoopChainList<HeadType, ElementType>::
			GetElementChainList(int k, ElementType& result)
			{
				if (k < 1)
					return false;
				LoopChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current->link != HeadPtr->first)                  //current指向第k个结点
				{
					current = current->link;
					i++;
				}
				if (current->link != HeadPtr->first)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			template<class HeadType,class ElementType>                            //四.查找函数2
			bool LoopChainList<HeadType, ElementType>::
			GetElementChainList(LoopChainNode<ElementType>* p, ElementType& result)
			{
				if (!p)
					return false;
				result = p->data;
				return true;
			}

			template<class HeadType,class ElementType>                            //四.查找函数3
			LoopChainNode<ElementType>* LoopChainList<HeadType,ElementType>::
			SearchElementChainList(int searchkey)
			{
				LoopChainNode<ElementType>* current = HeadPtr->first;
				while (current->link != HeadPtr->first && current->data.key != searchkey)
				{
					current = current->link;
				}
				if (current->link != HeadPtr->first)
					return current;
				else
					return NULL;
			}

			template<class HeadType,class ElementType>                            //五.插入函数
			bool LoopChainList<HeadType, ElementType>::
			InsertElementChainList(int k,ElementType& newvalue)
			{
				if (k < 0)
					return false;
				LoopChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current->link != HeadPtr->first)                  //current指向第k个结点
				{
					current = current->link;
					i++;
				}
				if (k > 0 && current->link == HeadPtr->first)
					return false;
				LoopChainNode<ElementType>* p = new LoopChainNode<ElementType>;
				p->data = newvalue;
				if (k == 0)
				{
					p->link = HeadPtr->first;
					HeadPtr->first = p;
				}
				else
				{
					if (current->link == HeadPtr->first)                          //此时current指向最后一个结点
					{
						p->link = HEadPtr->first;
						current->link = p;
					}
					else
					{
						p->link = current->link;
						current->link = p;
					}
				}
				return true;
			}

			template<class HeadType,class ElementType>                            //六.删除函数
			bool LoopChainList<HeadType, ElementType>::
			DeleteElementChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				LoopChainNode<ElementType>* current = HeadPtr->first;
				if (k == 1)
				{
					HeadPtr->first = current->link;
				}
				else
				{
					LoopChainNode<ElementType>* p = HeadPtr->first;
					int i = 0;
					while (i < k - 1 && p)
					{
						p = p->link;                                              //p指向第k-1个结点
					}
					if(p->link==HeadPtr->first)

				}
			}
			//好难啊....先停一停




117.			#pragma once
			template<class ElementType>
			class DoubleChainNode
			{
			public:
				ElementType data;
				DoubleChainNode<ElementType>* prelink;                                         //前驱结点
				DoubleChainNode<ElementType>* nextlink;                                        //后继结点
			};

			template<class HeadType>
			class DoubleHeadNode
			{
			public:
				HeadType Hdata;
				DoubleChainNode<ElementType>* first;
			};

			template<class HeadType,class ElementType>
			class DoubleChainList
			{
			public:
				DoubleChainList();                                                           //构造函数
				~DoubleChainList();                                                          //析构函数
				int LengthDoubleChainList();                                                 //表长函数
				void DestroyElementsDoubleChainList();                                       //删除表中元素,只留下表头
				void PutValueDoubleHeadNode(HeadType& head)                                  //将数据放入表头
				{HeadPtr->Hdata = head};
				DoubleHeadNode<HeadType>* GetHeadPtrDoubleChianList()                        //获取表头指针
				{return HeadPtr;}
				DoubleChainNode<ElementType>* GetFirstPtrDoubleChainList()                   //获取第一个结点指针
				{return HeadPtr->first;}
				bool GetElementDoubleChainList(int k, ElementType& result);                  //1.查找函数
				bool GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result);
				DoubleChainNode<ElementType>* SearchElementDoubleChainList(int searchkey);   
				bool InsertElementDoubleChainList(int k, ElementType& newvalue);             //2.插入函数
				bool DeleteElementDoubleChainList(int k);                                    //3.删除函数
			private:
				DoubleHeadNode<HeadType>* HeadPtr;
			};



			template<class HeadType,class ElementType>                                      
			DoubleChainList<HeadType,ElementType>::
			DoubleChainList()
			{
				HeadPtr = new DoubleHeadNode;
				HeadPtr->first = NULL;
			}

			template<class HeadType,class ElementType>
			DoubleChainList<HeadType, ElementType>::
			~DoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				while (HeadPtr->first)
				{
					current = current->nextlink;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template<class HeadType,class ElementType>
			int DoubleChainList<HeadType,ElementType>::
			LengthDoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (current)
				{
					i++;
					current = current->nextlink;
				}
				return i;
			}

			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType, ElementType>::GetElementDoubleChainList(int k, ElementType& result)
			{
				if (k < 1)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)
				{
					current = current->nextlink;
					i++;
				}
				if (current)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			/*主要理解点:对于前后指针域的修改,一共有四个,插入newvalue的prelink,nextlink,第k个元素的nextlink,第k+1个元素的prelink(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			InsertElementDoubleChainList(int k, ElementType &newvalue)
			{
				if (k < 0)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)                                                     //指向第k个结点
				{
					current = current->nextlink;
					i++;
				}
				if (k > 0 && current == NULL)
					return false;
				DoubleChainNode<ElementType>* p = new DoubleChainNode<ElementType>;
				p->data = newvalue;
				if (k != 0)
				{
					p->nextlink = current->nextlink;                                         //注意理解两个指针(pre和next),课本P47,即前后结点都会与newvalue产生联系,要对他们的结点都进行修改
					p->prelink = current;
					DoubleChainNode<ElementType>* q = current->nextlink;                     //q指向第k+1个结点,该结点的prelink指向newvalue(新插入的结点)
					if (q)                                                                   //如果q为NULL,就不用修改prelink了
					{
						q->prelink = p;
					}
					current->nextlink = p;
				}
				else                                                                         //此时k==0,作为第一个结点插入
				{
					p->nextlink = HeadPtr->first;
					p->prelink = HeadPtr;
					DoubleChainNode<ElementType>* q = HeadPtr->first;
					if (q)                                                                 
					{
						q->prelink = p;
					}
					HeadPtr->first = p;
				}
				return true;
			}

			/*主要理解点:一般要修改第k-1个结点的nextlink和第k+1个结点的prelink,来删除第k个结点(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			DeleteElementDoubleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;                      //current用来指向第k-1个结点,帮助修改nextlink
				DoubleChainList<ElementType>* p;                                             //p用来指向第k+1个结点,帮助修改prelink
				if (k == 1)
				{
					p = current->nextlink;
					if (p)                                                                   //在p非空时,其prelink还是要修改的
					{
						p->prelink = HeadPtr;
					}
					HeadPtr->first = p;
				}
				else
				{
					int i = 0;
					while (i < k - 1)                                                        //将current指向第k-1个结点
					{
						current = current->nextlink;
					}
					if (!current||!current->nextlink)                      
					{
						return false;
					}
					else
					{
						DoubleChainNode<ElementType>* q = current->nextlink;                  //q指向第k个结点
						p = q->nextlink;                                                      //p指向第k+1个结点
						current->nextlink = p;
						if (p)
						{
							p->prelink = current;
						}	
					}
				}
				delete current;
				return true;
			}

			//还有查找操作为定义




118.			#include "DoubleList.h"

			int main()
			{
				DoubleHeadNode<HeadType>* HeadPtr;
				DoubleChainNode<ElementType>* p;
				HeadType ClassInformation = { 2004 };
				ElementType newvalue, result;

				//1.构建链表
				DoubleChainList<HeadType,ElementType> AppList;
				HeadPtr = AppList.GetHeadPtrDoubleChainList();
				AppList.PutValueDoubleHeadNode(ClassInformation);

				//2.输入链表数据

			}



119.			#include "DoubleList.h"

			int main()
			{
				DoubleHeadNode<HeadType>* HeadPtr;
				DoubleChainNode<ElementType>* p;
				HeadType ClassInformation = { 2004 };
				ElementType newvalue, result;
				int ID[4], age[4];
				int choice, k, searchkey;

				//1.构建链表
				DoubleChainList<HeadType,ElementType> AppList;
				HeadPtr = AppList.GetHeadPtrDoubleChainList();
				AppList.PutValueDoubleHeadNode(ClassInformation);

				//2.输入链表数据
				cout << "请输入数据:" << endl;
				for (int i = 1; i <= 4; i++)
				{
					cout << "学号:";
					cin >> ID[i];
					newvalue.ID = ID[i];
					cout << "年龄:" << endl;
					cin >> age[i];
					newvalue.age = age[i];
					AppList.InsertElementDoubleChainList(0, newvalue);
				}
				while (true)
				{
					cout << "请选择:" << endl;
					cin >> choice;
					cout << "-------------------------" << endl;
					cout << "1.计算链表长度" << endl;
					cout << "2.查找第k个元素" << endl;
					cout << "3.查找指定年龄的元素" << endl;
					cout << "4.插入新元素到第k个后面" << endl;
					cout << "5.删除第k个元素" << endl;
					cout << "6.输出链表" << endl;
					cout << "0.退出" << endl;
					cout << "-------------------------" << endl;
					system("cls");

					switch (choice)
					{
					case 1:
					{
						cout << "链表长度为:" << endl;
						cout << AppList.LengthDoubleChainList() << endl;
						break;
					}
					case 2:
					{
						cout << "请输入查找的序号:" << endl;
						cin >> k;
						if (AppList.GetElementDoubleChainList(k, result))
						{
							AppList.DisplayElementDoubleChainList(result);
						}
						else
						{
							cout << "查找失败!!";
						}
						break;
					}
					case 3:
					{
						cout << "请输入查找的年龄:" << endl;
						cin >> searchkey;
						p = AppList.SearchElementDoubleChainList(searchkey);
						if (p)
						{
							AppList.GetElementDoubleChainList(p, result);
							AppList.DisplayElementDoubleChainList(result);
						}
						else
						{
							cout << "查找失败!!";
						}
						break;
					}
					case 4:
					{
						cout << "请输入要插入的位置:" << endl;
						cin >> k;
						cout << "请输入插入元素的值:" << endl;
						cout << "学号:" << "   ";
						cin >> newvalue.ID;
						cout << "年龄:" << "   ";
						cin >> newvalue.age;
						if (AppList.InsertElementDoubleChainList(k, newvalue))
						{
							AppList.DisplayDoubleChainList(AppList);
						}
						else
						{
							cout << "插入失败!!";
						}
						break;
					}
					case 5:
					{
						cout << "请输入要删除的元素序号:" << endl;
						cin >> k;
						if (AppList.DeleteElementDoubleChainList(k))
						{
							AppList.DisplayDoubleChainList(AppList);
						}
						else
						{
							cout << "删除失败!!";
						}
						break;
					}
					case 6:
					{
						AppList.DisplayDoubleChainList(AppList);
						break;
					}
					case 0:
					{
						system("cls");
						return 0;
					}
					}
					system("pause");
					system("cls");
				}
				return 0;
			}






120.			#include "AppData.h"

			template<class ElementType>
			class DoubleChainNode
			{
				ElementType data;
				DoubleChainNode<ElementType>* prelink;
				DoubleChainNode<ElementType>* nextlink;
			};

			template<class HeadType>
			class DoubleHeadNode
			{
				HeadType Hdata;
				DoubleChainNode<ElementType>* first;
			};

			template<class HeadType,class ElementType>
			class DoubleChainList
			{
			public:
				DoubleChainList();
				~DoubleChainList();
				int LengthDoubleChainList();
				void PutValueDoubleHeadNode(HeadType& headvalue)
				{HeadPtr->Hdata = headvalue;};
				DoubleHeadNode<HeadType>* GetHeadPtrDoubleChainList()
				{return HeadPtr;};
				DoubleChainNode<ElementType>* GetFirstPtrDoubleChainList()
				{return HeadPtr->first;};

				bool GetElementDoubleChainList(int k, ElementType& result);
				bool GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result);
				DoubleChainNode<ElementType>* SearchElementDoubleChainList(int searchkey);
				bool InsertElementDoubleChainList(int k, ElementType& newvalue);
				bool DeleteElementDoubleChainList(int k);

				void DisplayElementDoubleChainList(ElementType result);
				void DisplayDoubleChainList(DoubleChainList<HeadType,ElementType>& AppList);
			private:
				DoubleHeadNode* HeadPtr;
			};



			template<class HeadType,class ElementType>
			DoubleChainList<HeadType, ElementType>::
			DoubleChainList()
			{
				HeadPtr = new DoubleHeadNode<HeadType>;
				HeadPtr->first = NULL;
			}

			template<class HeadType,class ElementType>
			DoubleChainList<HeadType, ElementType>::
			~DoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				while (HeadPtr->first)
				{
					current = current->nextlink;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template<class HeadType,class ElementType>
			int DoubleChainList<HeadType, ElementType>::
			LengthDoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (current)
				{
					i++;
					current = current->nextlink;
				}
				return i;
			}

			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			GetElementDoubleChainList(int k, ElementType& result)
			{
				if (k < 1)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)
				{
					current = current->nextlink;
					i++;
				}
				if (current)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result)
			{
				if (!current)
				{
					result = current->data;
					return true;
				}
				else
					return false;
			}

			template<class HeadType,class ElementType>
			DoubleChainNode<ElementType>* DoubleChainList<HeadType, ElementType>::
			SearchElementDoubleChainList(int searchkey)
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				while (current && current->data.key != searchkey)
				{
					current = current->nextlink;
				}
				if (current)
				{
					return current;
				}
				else
					return NULL;
			}

			/*主要理解点:对于前后指针域的修改,一共有四个,插入newvalue的prelink,nextlink,第k个元素的nextlink,第k+1个元素的prelink(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			InsertElementDoubleChainList(int k, ElementType& newvalue)
			{
				if (k < 0)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)
				{
					current = current->nextlink;
					i++;
				}
				if (k > 0 && !current)
				{
					return false;
				}
				DoubleChainNode<ElementType>* q = new DoubleChainNode<ElementType>;
				q->data = newvalue;
				if (k)
				{
					DoubleChainNode<ElementType>* p = current->nextlink;
					q->nextlink = current->nextlink;
					q->prelink = current;
					if (p)
					{
						p->prelink = q;

					}
					current->nextlink = q;
				}
				else
				{
					DoubleChainNode<ElementType>* p = HeadPtr->first;
					q->nextlink = HeadPtr->first;
					q->prelink = HeadPtr;
					if (p)
					{
						p->prelink = q;
					}
					HeadPtr->first = q;
				}
				return true;
			}

			/*主要理解点:一般要修改第k-1个结点的nextlink和第k+1个结点的prelink,来删除第k个结点(对于NULL无需做修改)*/
			template<class HeadType, class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			DeleteElementDoubleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;                      //current用来指向第k-1个结点,帮助修改nextlink
				DoubleChainList<ElementType>* p;                                             //p用来指向第k+1个结点,帮助修改prelink
				if (k == 1)
				{
					p = current->nextlink;
					if (p)                                                                   //在p非空时,其prelink还是要修改的
					{
						p->prelink = HeadPtr;
					}
					HeadPtr->first = p;
				}
				else
				{
					int i = 0;
					while (i < k - 1)                                                        //将current指向第k-1个结点
					{
						current = current->nextlink;
					}
					if (!current || !current->nextlink)
					{
						return false;
					}
					else
					{
						DoubleChainNode<ElementType>* q = current->nextlink;                  //q指向第k个结点
						p = q->nextlink;                                                      //p指向第k+1个结点
						current->nextlink = p;
						if (p)
						{
							p->prelink = current;
						}
					}
				}
				delete current;
				return true;
			}

			template<class HeadType,class ElementType>
			void DoubleChainList<HeadType,ElementType>::
			DisplayElementDoubleChainList(ElementType result)
			{
				cout << result.ID << "    ";
				cout << result.age << "    ";
			}

			template<class HeadType,class ElementType>
			void DoubleChainList<HeadType,ElementType>::
			DisplayDoubleChainList(DoubleChainList<HeadType,ElementType>& AppList)
			{
				DoubleChainNode<ElementType>* current;
				DoubleHeadNode<HeadType>* HeadPtr;

				HeadPtr = AppList.GetHeadPtrDoubleChainList();

				cout << "-----表头结点信息------" << endl;
				cout << " 班级" << endl;
				cout << HeadPtr->Hdata.num << "  ";
				cout << "-----------------------" << endl;

				current = HeadPtr->first;
				while (current)
				{
					cout << current->data.ID << "        ";
					current = current->nextlink;
				}
				cout << endl;

				current = HeadPtr->first;
				cout << "                  ";
				while (current)
				{
					cout << current->data.age << "      ";
					current = current->nextlink;
				}
				cout << endl;
			}





121.			#pragma once
			#include <iostream>
			#include <string>
			#include <stdlib.h>

			using namespace std;

			#define HEADSTUDENT HeadType
			#define STUDENT ElementType
			#define age key

			class HEADSTUDENT
			{
			public:
				int num;
			};

			class STUDENT
			{
			public:
				int ID;
				int age;
			};



122.			#include <iostream>
			#include <cstring>
			#include <stdlib.h>
			#include "AppData.h"
			#include "DoubleList.h"
			using namespace std;



			int main()
			{
				DoubleHeadNode<HeadType>* HeadPtr;
				DoubleChainNode<ElementType>* p;
				HeadType ClassInformation = { 2004 };
				ElementType newvalue, result;
				int ID[4], age[4];
				int choice, k, searchkey;

				//1.构建链表
				DoubleChainList<HeadType,ElementType> AppList;
				HeadPtr = AppList.GetHeadPtrDoubleChainList();
				AppList.PutValueDoubleHeadNode(ClassInformation);

				//2.输入链表数据
				cout << "请输入数据:" << endl;
				for (int i = 1; i <= 4; i++)
				{
					cout <<"第"<< i <<"位"<<endl;
					cout << "学号:";
					cin >> ID[i];
					newvalue.ID = ID[i];
					cout << "年龄:";
					cin >> age[i];
					newvalue.age = age[i];
					AppList.InsertElementDoubleChainList(0, newvalue);
				}
				//3.功能实现
				while (true)
				{
					cout << "-------------------------" << endl;
					cout << "1.计算链表长度" << endl;
					cout << "2.查找第k个元素" << endl;
					cout << "3.查找指定年龄的元素" << endl;
					cout << "4.插入新元素到第k个后面" << endl;
					cout << "5.删除第k个元素" << endl;
					cout << "6.输出链表" << endl;
					cout << "0.退出" << endl;
					cout << "-------------------------" << endl;
					cout << "请选择:" << endl;
					cin >> choice;
					system("cls");

					switch (choice)
					{
					case 1:
					{
						cout << "链表长度为:" << endl;
						cout << AppList.LengthDoubleChainList() << endl;
						break;
					}
					case 2:
					{
						cout << "请输入查找的序号:" << endl;
						cin >> k;
						if (AppList.GetElementDoubleChainList(k, result))
						{
							AppList.DisplayElementDoubleChainList(result);
						}
						else
						{
							cout << "查找失败!!";
						}
						break;
					}
					case 3:
					{
						cout << "请输入查找的年龄:" << endl;
						cin >> searchkey;
						p = AppList.SearchElementDoubleChainList(searchkey);
						if (p)
						{
							AppList.GetElementDoubleChainList(p, result);
							AppList.DisplayElementDoubleChainList(result);
						}
						else
						{
							cout << "查找失败!!";
						}
						break;
					}
					case 4:
					{
						cout << "请输入要插入的位置:" << endl;
						cin >> k;
						cout << "请输入插入元素的值:" << endl;
						cout << "学号:" << "   ";
						cin >> newvalue.ID;
						cout << "年龄:" << "   ";
						cin >> newvalue.age;
						if (AppList.InsertElementDoubleChainList(k, newvalue))
						{
							AppList.DisplayDoubleChainList(AppList);
						}
						else
						{
							cout << "插入失败!!";
						}
						break;
					}
					case 5:
					{
						cout << "请输入要删除的元素序号:" << endl;
						cin >> k;
						if (AppList.DeleteElementDoubleChainList(k))
						{
							AppList.DisplayDoubleChainList(AppList);
						}
						else
						{
							cout << "删除失败!!";
						}
						break;
					}
					case 6:
					{
						AppList.DisplayDoubleChainList(AppList);
						break;
					}
					case 0:
					{
						system("cls");
						return 0;
					}
					}
					system("pause");
					system("cls");
				}
				return 0;
			}



123.			template<class ElementType>
			class DoubleChainNode
			{
				public:
				ElementType data;
				DoubleChainNode<ElementType>* prelink;
				DoubleChainNode<ElementType>* nextlink;
			};

			template<class HeadType>
			class DoubleHeadNode
			{
				public:
				HeadType Hdata;
				DoubleChainNode<ElementType>* first;
			};

			template<class HeadType,class ElementType>
			class DoubleChainList
			{
			public:
				DoubleChainList();
				~DoubleChainList();
				int LengthDoubleChainList();
				void PutValueDoubleHeadNode(HeadType& headvalue)
				{HeadPtr->Hdata = headvalue;};
				DoubleHeadNode<HeadType>* GetHeadPtrDoubleChainList()
				{return HeadPtr;};
				DoubleChainNode<ElementType>* GetFirstPtrDoubleChainList()
				{return HeadPtr->first;};

				bool GetElementDoubleChainList(int k, ElementType& result);
				bool GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result);
				DoubleChainNode<ElementType>* SearchElementDoubleChainList(int searchkey);
				bool InsertElementDoubleChainList(int k, ElementType& newvalue);
				bool DeleteElementDoubleChainList(int k);

				void DisplayElementDoubleChainList(ElementType result);
				void DisplayDoubleChainList(DoubleChainList<HeadType,ElementType>& AppList);
			private:
				DoubleHeadNode<HeadType>* HeadPtr;
			};



			template<class HeadType,class ElementType>
			DoubleChainList<HeadType, ElementType>::
			DoubleChainList()
			{
				HeadPtr = new DoubleHeadNode<HeadType>;
				HeadPtr->first = NULL;
			}

			template<class HeadType,class ElementType>
			DoubleChainList<HeadType, ElementType>::
			~DoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				while (HeadPtr->first)
				{
					current = current->nextlink;
					delete HeadPtr->first;
					HeadPtr->first = current;
				}
				delete HeadPtr;
			}

			template<class HeadType,class ElementType>
			int DoubleChainList<HeadType, ElementType>::
			LengthDoubleChainList()
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (current)
				{
					i++;
					current = current->nextlink;
				}
				return i;
			}

			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			GetElementDoubleChainList(int k, ElementType& result)
			{
				if (k < 1)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)
				{
					current = current->nextlink;
					i++;
				}
				if (current)
				{
					result = current->data;
					return true;
				}
				return false;
			}

			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType,ElementType>::
			GetElementDoubleChainList(DoubleChainNode<ElementType>* current, ElementType& result)
			{
				if (!current)
				{
					result = current->data;
					return true;
				}
				else
					return false;
			}

			template<class HeadType,class ElementType>
			DoubleChainNode<ElementType>* DoubleChainList<HeadType, ElementType>::
			SearchElementDoubleChainList(int searchkey)
			{
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				while (current && current->data.key != searchkey)
				{
					current = current->nextlink;
				}
				if (current)
				{
					return current;
				}
				else
					return NULL;
			}

			/*主要理解点:对于前后指针域的修改,一共有四个,插入newvalue的prelink,nextlink,第k个元素的nextlink,第k+1个元素的prelink(对于NULL无需做修改)*/
			template<class HeadType,class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			InsertElementDoubleChainList(int k, ElementType& newvalue)
			{
				if (k < 0)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;
				int i = 0;
				while (i < k && current)
				{
					current = current->nextlink;
					i++;
				}
				if (k > 0 && !current)
				{
					return false;
				}
				DoubleChainNode<ElementType>* q = new DoubleChainNode<ElementType>;
				q->data = newvalue;
				if (k)
				{
					DoubleChainNode<ElementType>* p = current->nextlink;
					q->nextlink = current->nextlink;
					q->prelink = current;
					if (p)
					{
						p->prelink = q;

					}
					current->nextlink = q;
				}
				else
				{
					DoubleChainNode<ElementType>* p = HeadPtr->first;
					q->nextlink = HeadPtr->first;
					q->prelink = NULL;
					if (p)
					{
						p->prelink = q;
					}
					HeadPtr->first = q;
				}
				return true;
			}

			/*主要理解点:一般要修改第k-1个结点的nextlink和第k+1个结点的prelink,来删除第k个结点(对于NULL无需做修改)*/
			template<class HeadType, class ElementType>
			bool DoubleChainList<HeadType, ElementType>::
			DeleteElementDoubleChainList(int k)
			{
				if (k < 1 || !HeadPtr->first)
					return false;
				DoubleChainNode<ElementType>* current = HeadPtr->first;                      //current用来指向第k-1个结点,帮助修改nextlink
				DoubleChainNode<ElementType>* p;                                             //p用来指向第k+1个结点,帮助修改prelink
				if (k == 1)
				{
					p = current->nextlink;
					if (p)                                                                   //在p非空时,其prelink还是要修改的
					{
						p->prelink = NULL;
					}
					HeadPtr->first = p;
				}
				else
				{
					int i = 0;
					while (i < k - 1)                                                        //将current指向第k-1个结点
					{
						current = current->nextlink;
					}
					if (!current || !current->nextlink)
					{
						return false;
					}
					else
					{
						DoubleChainNode<ElementType>* q = current->nextlink;                  //q指向第k个结点
						p = q->nextlink;                                                      //p指向第k+1个结点
						current->nextlink = p;
						if (p)
						{
							p->prelink = current;
						}
					}
				}
				delete current;
				return true;
			}

			template<class HeadType,class ElementType>
			void DoubleChainList<HeadType,ElementType>::
			DisplayElementDoubleChainList(ElementType result)
			{
				cout << result.ID << "    ";
				cout << result.age << "    ";
			}

			template<class HeadType,class ElementType>
			void DoubleChainList<HeadType,ElementType>::
			DisplayDoubleChainList(DoubleChainList<HeadType,ElementType>& AppList)
			{
				DoubleChainNode<ElementType>* current;
				DoubleHeadNode<HeadType>* HeadPtr;

				HeadPtr = AppList.GetHeadPtrDoubleChainList();

				cout << "----------表头结点信息-----------" << endl;
				cout << "-----------班级:"<<HeadPtr->Hdata.num<<"-------------" << endl;
				cout << "---------------------------------" << endl;

				current = HeadPtr->first;
				while (current)
				{
					cout << current->data.ID << "       ";
					current = current->nextlink;
				}
				cout << endl;

				current = HeadPtr->first;
				while (current)
				{
					cout << current->data.age << "         ";
					current = current->nextlink;
				}
				cout << endl;
			}





124.			#pragma once
			#define HEADSTUDENT HeadType
			#define STUDENT ElementType
			#define age key

			class HEADSTUDENT
			{
			public:
				int num;
			};

			class STUDENT
			{
			public:
				int ID;
				int age;
			};







125.			//一元多项式的加法操作
			//原理:给出两个式子,将它们相加.链表数据中分别存放系数和指数,系数相同则相加,系数不同则按指数从大到小排列插入
			//输入:两行数字,分别表示两个式子,前面的数字表示系数,后面的式子表示指数,中间用空格逗号隔开
			//输出:一行多项式
			//示例:输入:3 6,4 4,6 0
			//         7 7,3 4,5 1
			//     输出:7x^7+3x^6+7x^4+5x+6

			#include <bits/stdc++.h>
			using namespace std;
			//定义数据
			class num
			{
			public:
				int first;
				int second;
			};
			class HeadNode 
			{
			public:
				num Hdata;
				ChainNode* first;
			};
			class ChainNode
			{
			public:
				num data;
				ChainNode* link;
			};
			class ChainList
			{
			public:
				ChainList();
				~ChainList();
				void InsertElement(int k, num& newvalue);
			private:
				HeadNode* HeadPtr;
			};

			//功能函数
			void InsertElement(int k, num& newvalue)
			{
				HeadNode *HeadPtr;
				ChainNode* current = HeadPtr->first;
				for (int i = 0; i < k && current; i++)
				{
					current = current->link;
				}
				ChainNode* p;
				p->data = newvalue;
				p->link = current->link;
				current->link = p;
			}

			//实现函数
			int main()
			{
				//1.构建链表
				ChainList List;
				//2.将输入的数据挨个插入到链表中
				int f[4], s[4];
				num newvalue;
				for (int i = 1; i <= 3; i++)
				{
					cout << "请输入1:";
					cout << "系数:";
					cin >> f[i];
					newvalue.first = f[i];
					cout << "指数:";
					cin >> s[i];
					newvalue.second = s[i];
					InsertElement(0, newvalue);
				}
				//3.
			}






126.			//一元多项式的加法操作
			//原理:给出两个式子,将它们相加.链表数据中分别存放系数和指数,系数相同则相加,系数不同则按指数从大到小排列插入
			//输入:两行数字,分别表示两个式子,前面的数字表示系数,后面的式子表示指数,中间用空格逗号隔开
			//输出:一行多项式
			//示例:输入:3 6,4 4,6 0
			//         7 7,3 4,5 1
			//     输出:7x^7+3x^6+7x^4+5x+6

			#include <bits/stdc++.h>
			using namespace std;
			//定义数据
			class num
			{
			public:
				int first;                               //系数
				int second;                              //指数
			};
			class HeadNode 
			{
			public:
				num Hdata;
				ChainNode* first;
			};
			class ChainNode
			{
			public:
				num data;
				ChainNode* link;
			};

			//功能函数
			void InsertElement(int k, num& newvalue)
			{
				HeadNode *HeadPtr;
				ChainNode* current = HeadPtr->first;
				for (int i = 0; i < k && current; i++)
				{
					current = current->link;
				}
				ChainNode* p;
				p->data = newvalue;
				p->link = current->link;
				current->link = p;
			}

			void Add(HeadNode* L1, HeadNode* L2, HeadNode* L3)
			{
				ChainNode* p, * q, * r, * x;
				int choice,first;
				//链表L1和L2相加,结果存在L3中
				p = L1->first;
				q = L2->first;
				r = NULL;
				while (p && q)
				{
					if (p->data.second > q->data.second)
						choice = 1;
					if (p->data.second == q->data.second)
						choice = 2;
					if (p->data.second < q->data.second)
						choice = 3;
					switch (choice)
					{
					case 1:
					{
						x = new ChainNode;
						x->data.second = p->data.second;
						x->data.first = p->data.first;
						x->link = NULL;
						if (r)
							r->link = x;
						else
							L3->first = x;
						r = x;
						p = p->link;
						break;
					}
					case 2:
					{
						first = p->data.first + q->data.first;
						if (first)                              //此时系数非零
						{
							x = new ChainNode;
							x->data.first = first;
							x->data.second = p->data.second;
							x->link = NULL;
							if (r)
								r->link = x;
							else
								L3->first = x;
							r = x;
						}
						p = p->link;
						q = q->link;
						break;
					}
					case 3:
					{
						x = new ChainNode;
						x->data.first = q->data.first;
						x->data.second = q->data.first;
						x->link = NULL;
						if (r)
							r->link = x;
						else
							L3->first = x;
						r = x;
						q = q->link;
						break;
					}
				}
			}

			//实现函数
			int main()
			{
				//1.构建链表
				HeadNode *List1;
				HeadNode *List2;

				//2.将输入的数据挨个插入到链表中
				int a, b;
				x = new ChainNode;
				cout << "请输入1:";
				cout << "系数:";
				cin >> a;
				x->data.first = a;
				cout << "指数:";
				cin >> b;
				x->data.second = b;
				x->link = NULL;


				{
					cin >> f[i];
					newvalue.first = f[i];

					cin >> s[i];
					newvalue.second = s[i];
					InsertElement(0, newvalue);
				}
				//3.
			}
			
			
			
			
			
127.			#include <iostream>
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			#include <conio.h>
			using namespace std;


			typedef struct
			{
				int ID;
				char name[20];
			}student;

			student stu[5];

			typedef student EType;

			//1.作者信息
			void Inform()                  
			{
				printf("\n\n\n\n\n\n\n");
				printf("              *************************************************\n");
				printf("                           学生成绩单的混合表存储\n\n");
				printf("                           制作:xxx\n");
				printf("                           班级:xxx\n");
				printf("                           学号:xxx\n");
				printf("                           指导老师:孙夫雄\n");
				printf("              **************************************************\n");
				printf("\n\n\n\t\t");
			}
			//2.输入数据
			void Input(student stu[], int k)
			{
				printf("请输入相应数据:\n");
				for (int i = 0; i < k; i++)
				{
					printf("请输入第%d个学生的学号:", i + 1);
					cin >> stu[i].ID;
					printf("请输入姓名:");
					cin >> stu[i].name;
					printf("\n");
				}
			}




			//一.顺序栈//

			typedef struct
			{
				EType* element;
				int top;
				int MaxSize;
			}Stack;

			Stack S;

			//1.构建堆栈
			void Create1(Stack& S, int MaxSize)
			{
				S.MaxSize = MaxSize;
				S.element = new EType[S.MaxSize];
				S.top = -1;
			}

			//2.判断栈空
			bool IsEmpty1(Stack& S)
			{
				if (S.top == -1)
					return true;
				return false;
			}

			//3.判断栈满
			bool IsFull1(Stack& S)
			{
				if (S.top == S.MaxSize - 1)
					return true;
				return false;
			}

			//4.入栈操作
			bool Push1(Stack& S, EType& x)
			{
				if (IsFull1(S))
					return false;
				S.top++;
				S.element[S.top].ID = x.ID;
				strcpy(S.element[S.top].name, x.name);
				return true;
			}

			//5.出栈操作
			bool Pop1(Stack& S, EType& x)
			{
				if (IsEmpty1(S))
					return false;
				x.ID = S.element[S.top].ID;
				strcpy(x.name, S.element[S.top].name);
				S.top--;
				return true;
			}

			//6.输入操作
			void InPut1(Stack& S, student stu[], int k)
			{
				for (int i = 0; i < k; i++)              //将之前输入的数组学生数据存到栈中
				{
					S.element[i].ID = stu[i].ID;
					strcpy(S.element[i].name , stu[i].name);
					S.top++;
				}
			}

			//7.输出操作
			void OutPut1(Stack& S)
			{
				if (IsEmpty1(S))
				{
					printf("空栈!");
				}
				else
				{
					printf("元素显示(顺序栈)如下:\n");
					for (int i = 0; i <= S.top; i++)
					{
						cout << "第" << i + 1 << "名学生\n";
						cout << "学号:" << S.element[i].ID << "\t";
						cout << "姓名:" << S.element[i].name << "\n";
					}
				}
			}




			//二.链式栈//

			typedef struct
			{
				EType data;
				StackNode* link;
			}StackNode;

			typedef struct
			{
				int len;
				StackNode* top;
			}StackFirst;

			StackFirst* SS;

			//1.构建堆栈
			StackFirst* Create2(StackFirst* SS)
			{
				SS = new StackFirst;
				SS->top = NULL;
				return SS;
			}

			//2.判断栈空
			bool IsEmpty2(StackFirst* SS)
			{
				if (SS->top)
					return false;
				return true;
			}

			//3.入栈操作
			bool Push2(StackFirst* SS, EType& x)
			{
				StackNode* p = new StackNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty2(SS))
				{
					SS->top = p;
					p->link = NULL;
				}
				else
				{
					p->link = SS->top;
					SS->top = p;
				}
				return true;
			}

			//4.出栈操作
			bool Pop2(StackFirst* SS, EType& x)
			{
				if (IsEmpty2(SS))
				{
					cout << "空栈!";
					return false;
				}
				StackNode* p = new StackNode;
				p = SS->top;
				x.ID = p->data.ID;
				strcpy(x.name, p->data.name);
				SS->top = p->link;
				delete p;
				return true;
			}

			//5.输入操作
			void InPut2(StackFirst* SS, student stu[], int k)
			{
				for (int i = 0; i < k; i++)
				{
					Push2(SS, stu[i]);
				}
			}

			//6.输出操作
			void OutPut2(StackFirst* SS)
			{
				if (IsEmpty2(SS))
				{
					cout << "空栈!";
				}
				else
				{
					StackNode* p = SS->top;
					printf("元素显示(链式栈)如下:\n");
					int i = 1;
					while (p)
					{
						cout << "第" << i << "名学生:\n";
						cout << "学号:" << p->data.ID << '\t';
						cout << "姓名:" << p->data.name << '\n';
						p = p->link;
						i++;
					}
				}
			}








			//总输出函数//
			bool OutPut(int n)
			{
				switch (n)
				{
				case 1:
					OutPut1(S);
					break;
				case 2:
					OutPut2(SS);
					break;
				default:
					return 0;
				}
			}

			//总入栈操作//
			bool InPut(int n,EType &x)
			{
				switch (n)
				{
				case 1:
					return Push1(S, x);
				case 2:
					return Push2(SS, x);
				default:
					return 0;
				}
			}

			//总出栈操作//
			bool Pop(int n, EType& x)
			{
				switch (n)
				{
				case 1:
					return Pop1(S, x);
				case 2:
					return Pop2(SS, x);
				default:
					return 0;
				}
			}


			//第一级选择菜单//
			void MenuFirst()
			{
				cout << "\n\t\t" << "请选择以下一个功能:" << endl;
				cout << "\n\t\t" << "1.顺序栈." << endl;
				cout << "\t\t2.链式栈." << endl;
				cout << "\t\t3.退出.\n" << endl;
			}




128.			#include <bits/stdc++.h>
			using namespace std;
			int main()
			{
				int k;
				while(1)
				{
				cout<<"请选择操作:"<<'\n';
				cout<<"1.相加"<<'\n';
				cout<<"2.相减"<<'\n';
				cout<<"3.相乘"<<'\n';
				cout<<"4.退出"<<'\n';
				cin>>k;  
				system("cls");
				switch(k)
				{
					case 1:
						{
							int a,b;
							cout<<"请输入两个加数:\n";
							cin>>a>>b;
							cout<<"结果:"<<a+b<<'\n';
							break;
						}
					case 2:
						{
							int a,b;
							cout<<"请输入两个减数:\n";
							cin>>a>>b;
							cout<<"结果:"<<a-b<<'\n';
							break;
						}
					case 3:
					{
						int a,b;
						cout<<"请输入两个乘数:\n";
						cin>>a>>b;
						cout<<"结果:"<<a*b<<'\n';
						break;
					}
					case 4:
					{
					system("cls");
					return 0;	
					}
				}
				system("pause");
				system("cls");
			 } 
				system("pause");
				return 0;
			}






129.			#include <iostream>
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			#include <conio.h>
			using namespace std;


			typedef struct
			{
				int ID;
				char name[20];
			}student;

			student stu[5];

			typedef student EType;

			//1.作者信息
			void Inform()                  
			{
				printf("\n\n\n\n\n\n\n");
				printf("              *************************************************\n");
				printf("                           学生成绩单的混合表存储\n\n");
				printf("                           制作:xxx\n");
				printf("                           班级:xxx\n");
				printf("                           学号:xxx\n");
				printf("                           指导老师:孙夫雄\n");
				printf("              **************************************************\n");
				printf("\n\n\n\t\t");
			}
			//2.输入数据
			void Input(student stu[], int k)
			{
				printf("请输入相应数据:\n");
				for (int i = 0; i < k; i++)
				{
					printf("请输入第%d个学生的学号:", i + 1);
					cin >> stu[i].ID;
					printf("请输入姓名:");
					cin >> stu[i].name;
					printf("\n");
				}
			}




			//一.顺序栈//

			typedef struct
			{
				EType* element;
				int top;
				int MaxSize;
			}Stack;

			Stack S;

			//1.构建堆栈
			void Create1(Stack& S, int MaxSize)
			{
				S.MaxSize = MaxSize;
				S.element = new EType[S.MaxSize];
				S.top = -1;
			}

			//2.判断栈空
			bool IsEmpty1(Stack& S)
			{
				if (S.top == -1)
					return true;
				return false;
			}

			//3.判断栈满
			bool IsFull1(Stack& S)
			{
				if (S.top == S.MaxSize - 1)
					return true;
				return false;
			}

			//4.入栈操作
			bool Push1(Stack& S, EType& x)
			{
				if (IsFull1(S))
					return false;
				S.top++;
				S.element[S.top].ID = x.ID;
				strcpy(S.element[S.top].name, x.name);
				return true;
			}

			//5.出栈操作
			bool Pop1(Stack& S, EType& x)
			{
				if (IsEmpty1(S))
					return false;
				x.ID = S.element[S.top].ID;
				strcpy(x.name, S.element[S.top].name);
				S.top--;
				return true;
			}

			//6.输入操作
			void InPut1(Stack& S, student stu[], int k)
			{
				for (int i = 0; i < k; i++)              //将之前输入的数组学生数据存到栈中
				{
					S.element[i].ID = stu[i].ID;
					strcpy(S.element[i].name , stu[i].name);
					S.top++;
				}
			}

			//7.输出操作
			void OutPut1(Stack& S)
			{
				if (IsEmpty1(S))
				{
					printf("空栈!");
				}
				else
				{
					printf("元素显示(顺序栈)如下:\n");
					for (int i = 0; i <= S.top; i++)
					{
						cout << "第" << i + 1 << "名学生\n";
						cout << "学号:" << S.element[i].ID << "\t";
						cout << "姓名:" << S.element[i].name << "\n";
					}
				}
			}




			//二.链式栈//

			typedef struct StackNode
			{
				EType data;
				StackNode* link;
			}StackNode;

			typedef struct
			{
				int len;
				StackNode* top;
			}StackFirst;

			StackFirst* SS;

			//1.构建堆栈
			StackFirst* Create2(StackFirst* SS)
			{
				SS = new StackFirst;
				SS->top = NULL;
				return SS;
			}

			//2.判断栈空
			bool IsEmpty2(StackFirst* SS)
			{
				if (SS->top)
					return false;
				return true;
			}

			//3.入栈操作
			bool Push2(StackFirst* SS, EType& x)
			{
				StackNode* p = new StackNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty2(SS))
				{
					SS->top = p;
					p->link = NULL;
				}
				else
				{
					p->link = SS->top;
					SS->top = p;
				}
				return true;
			}

			//4.出栈操作
			bool Pop2(StackFirst* SS, EType& x)
			{
				if (IsEmpty2(SS))
				{
					cout << "空栈!";
					return false;
				}
				StackNode* p = new StackNode;
				p = SS->top;
				x.ID = p->data.ID;
				strcpy(x.name, p->data.name);
				SS->top = p->link;
				delete p;
				return true;
			}

			//5.输入操作
			void InPut2(StackFirst* SS, student stu[], int k)
			{
				for (int i = 0; i < k; i++)
				{
					Push2(SS, stu[i]);
				}
			}

			//6.输出操作
			void OutPut2(StackFirst* SS)
			{
				if (IsEmpty2(SS))
				{
					cout << "空栈!";
				}
				else
				{
					StackNode* p = SS->top;
					printf("元素显示(链式栈)如下:\n");
					int i = 1;
					while (p)
					{
						cout << "第" << i << "名学生:\n";
						cout << "学号:" << p->data.ID << '\t';
						cout << "姓名:" << p->data.name << '\n';
						p = p->link;
						i++;
					}
				}
			}








			//总输出函数//
			bool OutPut(int n)
			{
				switch (n)
				{
				case 1:
					OutPut1(S);
					break;
				case 2:
					OutPut2(SS);
					break;
				default:
					return 0;
				}
			}

			//总入栈操作//
			bool InPut(int n,EType &x)
			{
				switch (n)
				{
				case 1:
					return Push1(S, x);
				case 2:
					return Push2(SS, x);
				default:
					return 0;
				}
			}

			//总出栈操作//
			bool Pop(int n, EType& x)
			{
				switch (n)
				{
				case 1:
					return Pop1(S, x);
				case 2:
					return Pop2(SS, x);
				default:
					return 0;
				}
			}


			//第一级选择菜单//
			void Menu1()
			{
				cout << "\n\t\t" << "请选择以下一个功能:" << endl;
				cout << "\n\t\t" << "1.顺序栈." << endl;
				cout << "\t\t2.链式栈." << endl;
				cout << "\t\t3.退出.\n" << endl;
			}
			int MenuFirst(int n,int &Flag)         //Flag表示是否退出,flag表示选择
			{
				int flag;
				switch (n)
				{
				case 1:
				{
					flag = 1;
					break;
				}
				case 2:
				{
					flag = 2;
					break;
				}
				case 3:
				{
					flag = 3;
					return 0;
				}
				default:
				{
					cout << "选择非法!" << endl;
					Flag = 0;
					system("pause");
					system("cls");
					break;
				}
				}
				return flag;
			}


			//第二级选择菜单//
			void Menu2(int flag)
			{
				char choose[][10] = { "顺序栈","链式栈" };
				cout << "\n\t\t" << "请选择以下一个功能:" << endl;
				cout << "\n\t\t" << "1.显示" << choose[flag - 1] << endl;
				cout << "\t\t2.插入" << choose[flag - 1] << "中数据元素." << endl;
				cout << "\t\t3.删除" << choose[flag - 1] << "中数据元素." << endl;
				cout << "\t\t4.返回." << endl;
			}
			int MenuSecond(int flag,int k)
			{
				EType x;	
				switch (k)
				{
				case 1:
				{
					system("cls");
					OutPut(flag);
					system("pause");
					system("cls");
					break;
				}
				case 2:
				{
					system("cls");
					cout << "输入学号:";
					cin >> x.ID;
					cout << "输入姓名:";
					cin >> x.name;
					if (InPut(flag, x))
					{
						cout<<"插入成功!"<<endl;
						OutPut(flag);
					}
					else
					{
						cout << "插入失败!" << endl;
					}
					system("pause");
					system("cls");
					break;
				}
				case 3:
				{
					system("cls");
					if (Pop(flag, x))
					{
						cout << "删除成功!" << endl;
						OutPut(flag);
					}
					else
					{
						cout << "删除失败!" << endl;
					}
					system("pause");
					system("cls");
					break;
				}
				case 4:
				{
					exit(0);
					break;
				}
				default:
				{
					cout << "选择非法!" << endl;
					system("pause");
					system("cls");
					break;
				}
				}
			}


			//主函数//
			int main()
			{
				student stu[10]; 
				int MaxSize = 40, k;
				cout << "请输入学生数量:" << endl;
				cin >> k;
				Create1(S, MaxSize);
				SS = Create2(SS);

				Input(stu,k);
				InPut1(S, stu, k);
				InPut2(SS, stu, k);

				while (1)
				{
					int k, Flag = 1;
					Menu1();
					cout << "请输入选择:" << endl;
					cin >> k;
					system("cls");
					if (k == 3)
					{
						break;
					}
					MenuFirst(k, Flag);                       //如果输入defalt,Flag就会变成0
					int flag = MenuFirst(k, Flag);            //flag中存储选项(顺序栈or链式栈)
					while (Flag)
					{
						Menu2(flag);
						int t;
						cout << "请输入选择:";
						cin >> t;
						if (t == 4)
						{
							system("cls");
							break;
						}
						MenuSecond(flag, t);
					}
					fflush(stdin);
				}
				return 0;
			}








130.			#pragma once
			#include "AppData.h"
			template<class StackType>
			class Stack
			{
			public:
				Stack(int MaxSize = 10);
				~Stack(){delete[] element;}
				int GetAddress() { return top; }
				bool IsEmpty() { return top == -1; }
				bool IsFull(){ return top >= MaxSize - 1; }
				bool Push(StackType& newvalue);
				bool Pop(StackType& result);
				void Display();
				void DisplayElement(int i);
			private:
				int top;
				int MaxSize;
				StackType* element;
			};

			template<class StackType>
			Stack<StackType>::Stack(int MaxSize)
			{
				MaxSize = 10;
				element = new StackType[MaxSize];
				top = -1;
			}

			template<class StackType>
			bool Stack<StackType>::Push(StackType& newvalue)
			{
				if (IsFull())
					return false;
				top++;
				element[top] = newvalue;
				return true;
			}

			template<class StackType>
			bool Stack<StackType>::Pop(StackType& result)
			{
				if (IsEmpty())
					return false;
				result = element[top];
				top--;
				return true;
			}

			template<class StackType>
			void Stack<StackType>::Display()
			{
				cout << "**********输出堆栈**********" << endl;
				cout << "学号        年龄        姓名" << endl;
				for (int i = top; i >= 0; i--)
				{
					cout << "第" << i << "名学生:"
						<< element[i].ID << "       "
						<< element[i].age << "       "
						<< element[i].name << endl;
				}
			}

			template<class StackType>
			void Stack<StackType>::DisplayElement(int i)
			{
				cout << "第" << i << "名学生:"
					<< element[i].ID << "       "
					<< element[i].age << "       "
					<< element[i].name << endl;
			}





131.			#pragma once
			#define STUDENT EType
			class STUDENT
			{
			public:
				int ID;
				int age;
				int name;
			};




132.			#include <iostream>
			#include <cstring>
			#include <stdlib.h>
			#include <conio.h>
			#include "AppData.h"
			#include "Stack.h"
			using namespace std;

			int main()
			{
				int MaxSize = 10;
				EType newvalue, result;
				Stack<EType> AppStack(MaxSize);
				int k, choice;
				cout << "请输入学生数量:" << endl;
				cin >> k;
				for (int i = 0; i < k; i++)
				{
					cout<<"第"<<i+1<<"名学生:"<<endl;
					cout << "请输入学号:";
					cin >> newvalue.ID;
					cout << "请输入年龄:";
					cin >> newvalue.age;
					cout << "请输入姓名:";
					cin >> newvalue.name;
					AppStack.Push(newvalue);
					cout<<endl;
				}
				system("cls");
				while (1)
				{
					cout << "********堆栈顺序存储的运算********" << endl;
					cout << "   1------输出堆栈中的所有元素" << endl;
					cout << "   2------返回堆栈的栈顶元素" << endl;
					cout << "   3------进栈" << endl;
					cout << "   4------退栈" << endl;
					cout << "   0------退出" << endl;
					cout << "***************************************************************" << endl;
					cout << "请选择处理功能：";
					cin >> choice;
					system("cls");
					switch (choice)
					{
					case 1:
					{
						AppStack.Display();
						break;
					}
					case 2:
					{
						if (!AppStack.IsEmpty())
						{
							int i = AppStack.GetAddress();
							AppStack.DisplayElement(i);
						}
						else
						{
							cout << "栈空!" << endl;
						}
						break;
					}
					case 3:
					{
						if (AppStack.IsFull())
						{
							cout << "栈满!" << endl;
						}
						else
						{
							cout << "请输入学号:" << endl;
							cin >> newvalue.ID;
							cout << "请输入年龄:" << endl;
							cin >> newvalue.age;
							cout << "请输入姓名:" << endl;
							cin >> newvalue.name;
							AppStack.Push(newvalue);
							cout << "结果如下:" << endl;
							AppStack.Display();
						}
						break;
					}
					case 4:
					{
						if (AppStack.IsEmpty())
						{
							cout << "栈空!" << endl;
						}
						else
						{
							AppStack.Pop(result);
							AppStack.DisplayElement(AppStack.GetAddress());
							cout << endl << endl;
							cout << "结果如下" << endl;
							AppStack.Display();
						}
						break;
					}
					case 0:
					{
						return 0;
						break;
					}
					}
					system("pause");
					system("cls");
				}
			}




133.			#include <iostream>
			#include <bits/stdc++.h>
			using namespace std;

			//定义数据
			typedef struct
			{
				int ID;
				char name[20];
			}student;
			typedef student ElementType;

			//定义队列
			typedef struct
			{
				ElementType* element;
				int front;
				int end;
				int MaxSize;
			}Team;

			//建立队列
			Team Create(int MaxSize, Team& S)
			{
				S.MaxSize = MaxSize;
				S.element = new ElementType[S.MaxSize];
				S.front = 0;
				S.end = 0;
				return S;
			}

			//判断队空
			bool IsEmpty(Team& S)
			{
				if (S.front == S.end)
					return true;
				return false;
			}

			//判断队满
			bool IsFull(Team& S)
			{
				if (S.front == (S.end + 1) % (S.MaxSize + 1))
					return true;
				return false;
			}

			//入队操作
			bool In(Team& S, ElementType& x)
			{
				if (IsFull(S))
					return false;
				else
				{
					S.end = (S.end + 1) % (S.MaxSize + 1);
					S.element[S.end].ID = x.ID;
					strcpy(S.element[S.end].name, x.name);
					return true;
				}
			}

			//出队操作
			bool Out(Team& S, ElementType& result)
			{
				if (IsEmpty(S))
					return false;
				else
				{
					result.ID = S.element[S.front+1].ID;
					strcpy(result.name, S.element[S.front+1].name);
					S.front = (S.front + 1) % (S.MaxSize + 1);
					return true;
				}
			}

			//显示函数
			void Display(Team& S)
			{
				cout << "*****学生数据*****" << endl;
				cout << "学号               姓名" << endl;
				for (int i = S.front + 1; (i-1)% (S.MaxSize + 1) != S.end; i++)
				{
					cout << S.element[i].ID << "              " << S.element[i].name << endl;
				}
				cout << "*****************" << endl;
			}

			//显示菜单
			void Menu()
			{
				cout << "功能菜单如下:" << endl;
				cout << "1.显示学生信息" << endl;
				cout << "2.插入队尾数据" << endl;
				cout << "3.删除队头数据" << endl;
				cout << "4.退出" << endl << endl;
				cout << "请输入选择:";
			}

			//主函数
			int main()
			{
				int n, k, choice;
				ElementType x, result;
				cout << "请输入最大学生数:";
				cin >> n;
				Team S;
				S = Create(n, S);
				cout << "请输入当前学生数:";
				cin >> k;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> x.ID;
					cout << "姓名:";
					cin >> x.name;
					cout << endl;
					In(S, x);
				}

				system("cls");
				while (1)
				{
					Menu();
					cin >> choice;
					system("cls");
					switch (choice)
					{
					case 1:
					{
						Display(S);
						break;
					}
					case 2:
					{
						if (IsFull(S))
						{
							cout << "队列已满!" << endl;
							break;
						}
						else
						{
							cout << "请输入要插入学生的数据:" << endl;
							cout << "学号:";
							cin >> x.ID;
							cout << "姓名:";
							cin >> x.name;
							In(S, x);
							cout << endl << endl;
							cout << "插入后结果如下:" << endl;
							Display(S);
							break;
						}
					}
					case 3:
					{
						if (IsEmpty(S))
						{
							cout << "队列为空!" << endl;
							break;
						}
						else
						{
							Out(S, result);
							cout << "删除的学生数据如下:" << endl;
							cout << "学号:" << result.ID << "           " << "姓名:" << result.name << endl << endl;
							cout << "删除后结果如下:" << endl;
							Display(S);
							break;
						}
					}
					case 4:
					{
						return 0;
					}
					}
					system("pause");
					system("cls");
				}
			}





134.			#include <iostream>
			#include <bits/stdc++.h>
			using namespace std;

			//学生数据
			typedef struct
			{
				int ID;
				char name[10];
			}student;

			typedef student ElementType;

			//链表结点
			typedef struct StackNode
			{
				ElementType data;
				StackNode* link;
			}StackNode;

			//定义链表
			typedef struct
			{
				int len;
				StackNode* top;
			}Stack;

			//构建链表
			Stack* CreateStack(Stack* S)
			{
				S = new Stack;
				S->top = NULL;
				return S;
			}

			bool IsEmpty(Stack* S)
			{
				if (!S->top)
					return true;
				return false;
			}

			bool Push(Stack* S, ElementType& x)
			{
				StackNode* p = new StackNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty(S))
				{
					S->top = p;
					p->link = NULL;
				}
				else
				{
					p->link = S->top;
					S->top = p;
				}
				return true;
			}

			bool Pop(Stack* S, ElementType& result)
			{
				if (IsEmpty(S))
					return false;
				StackNode* p = new StackNode;
				p = S->top;
				result.ID = p->data.ID;
				strcpy(result.name, p->data.name);
				S->top = p->link;
				delete p;
				return true;
			}

			void Display(Stack* S)
			{
				StackNode* p = new StackNode;
				p = S->top;
				cout << "*****学生数据*****" << endl;
				cout << "学号               姓名" << endl;
				while (p)
				{
					cout << p->data.ID << "          " << p->data.name << endl;
					p = p->link;
				}
				cout << "*****************" << endl;
			}

			void Menu()
			{
				cout << "功能菜单如下:" << endl;
				cout << "1.显示学生信息" << endl;
				cout << "2.插入学生数据" << endl;
				cout << "3.删除最后学生数据" << endl;
				cout << "4.退出" << endl << endl;
			}

			//主函数
			int main()
			{
				int k, choice;
				cout << "请输入当前学生数量:" << endl;
				cin >> k;
				Stack* S;
				S=CreateStack(S);
				ElementType newvalue, result;
				cout << endl << "请输入学生数据:" << endl;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					Push(S, newvalue);
						cout<<endl;
				}
				system("cls");
				while (1)
				{
					Menu();
					cout << "请输入选择功能:";
					cin >> choice;
					system("cls");
					switch (choice)
					{
					case 1:
					{
						Display(S);
						break;
					}
					case 2:
					{
						cout << "请输入插入数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						Push(S, newvalue);
						cout << endl << "插入后结果如下:" << endl;
						Display(S);
						break;
					}
					case 3:
					{
						if (IsEmpty(S))
							cout << "栈空!";
						Pop(S, result);
						cout << "删除的数据如下:" << endl;
						cout << "学号:" << result.ID << "           " << "姓名:" << result.name << endl;
						cout << endl << "删除后结果如下:" << endl;
						Display(S);
						break;
					}
					case 4:
					{
						return 0;
						break;
					}
					}
					system("pause");
					system("cls");
				}
				system("pause");
			}





135.			#include <bits/stdc++.h>
			using namespace std;

			//学生数据
			typedef struct
			{
				int ID;
				char name[20];
			}student;
			typedef student ElementType;

			//链队结点
			typedef struct TeamNode
			{
				ElementType data;
				TeamNode* link;
			}TeamNode;

			//链队
			typedef struct
			{
				int MaxSize;
				TeamNode* front;
				TeamNode* end;
			}Team;


			//创建链队
			Team* Create(Team* S, int MaxSize)
			{
				S = new Team;
				S->MaxSize = MaxSize;
				S->front = NULL;
				S->end = NULL;
				return S;
			}

			//判断队空
			bool IsEmpty(Team* S)
			{
				if (!S->front)
					return true;
				return false;
			}

			//插入
			bool In(Team* S, ElementType& x)
			{
				TeamNode* t = new TeamNode;
				t->data.ID = x.ID;
				strcpy(t->data.name, x.name);
				t->link = NULL;
				if (IsEmpty(S))
				{
					S->front = t;
					S->end = t;
				}
				else
				{
					TeamNode* q = S->end;
					q->link = t;
					S->end = t;
				}
				return true;
			}

			//弹出
			bool Out(Team* S, ElementType& result)
			{
				if (IsEmpty(S))
					return false;
				TeamNode* q = new TeamNode;
				q = S->front;
				result.ID = q->data.ID;
				strcpy(result.name,q->data.name);
				S->front = q->link;
				delete q;
				return true;
			}

			//输出
			void Display(Team* S)
			{
				if (IsEmpty(S))
				{
					cout << "队空!" << endl;
				}
				else
				{
					cout << "*****学生数据*****" << endl;
					cout << "学号          姓名" << endl;
					TeamNode* p = S->front;
					while (p)
					{
						cout << p->data.ID << "          " << p->data.name << endl;
						p = p->link;
					}
					cout << "*****************" << endl;
				}
			}

			//菜单
			void Menu()
			{
				cout << "功能菜单如下:" << endl;
				cout << "1.显示学生信息" << endl;
				cout << "2.插入队尾数据" << endl;
				cout << "3.删除队头数据" << endl;
				cout << "4.退出" << endl << endl;
				cout << "请输入选择:";
			}


			//主函数
			int main()
			{
				int k, choice;
				ElementType x, result;
				cout << "请输入当前学生数:";
				cin >> k;
				Team* S = new Team;
				S = Create(S, k);
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> x.ID;
					cout << "姓名:";
					cin >> x.name;
					cout << endl;
					In(S, x);
				}
				system("cls");
				//数据输入结束,开始执行功能
				while (1)
				{
					Menu();
					cin >> choice;
					system("cls");
					switch (choice)
					{
					case 1:
					{
						Display(S);
						break;
					}
					case 2:
					{
						cout << "请输入要插入学生的数据:" << endl;
						cout << "学号:";
						cin >> x.ID;
						cout << "姓名:";
						cin >> x.name;
						In(S, x);
						cout << endl << endl;
						cout << "插入后结果如下:" << endl;
						Display(S);
						break;
					}
					case 3:
					{
						if (IsEmpty(S))
						{
							cout << "队列为空!" << endl;
							break;
						}
						else
						{
							Out(S, result);
							cout << "删除的学生数据如下:" << endl;
							cout << "学号:" << result.ID << "           " << "姓名:" << result.name << endl << endl;
							cout << "删除后结果如下:" << endl;
							Display(S);
							cout << endl << endl;
							break;
						}
					}
					case 4:
					{
						return 0;
					}
					}
					system("pause");
					system("cls");
				}
			}







136.			#include <bits/stdc++.h>
			using namespace std;

			/*学生数据*/
			typedef struct
			{
				int ID;
				char name[10];
			}student;
			typedef student ElementType;

			/*开始定义不同结构操作*/


			/*1.顺序栈*/
			//定义顺序栈
			typedef struct
			{
				ElementType* element;
				int MaxSize;
				int top;
			}Stack1;

			//创建顺序栈
			Stack1 Create1(Stack1& S1, int MaxSize)
			{	
				S1.MaxSize = MaxSize;
				S1.element = new ElementType[S1.MaxSize];
				S1.top = -1;
				return S1;
			}

			//判断栈空
			bool IsEmpty1(Stack1& S1)
			{
				if (S1.top == -1)
					return true;
				return false;
			}

			//判断栈满
			bool IsFull1(Stack1& S1)
			{
				if (S1.top == S1.MaxSize - 1)
					return true;
				return false;
			}

			//入栈
			bool Push1(Stack1& S1, ElementType& x)
			{
				if (IsFull1(S1))
					return false;
				S1.top++;
				S1.element[S1.top].ID = x.ID;
				strcpy(S1.element[S1.top].name, x.name);
			}

			//出栈
			bool Pop1(Stack1& S1, ElementType& result)
			{
				if (IsEmpty1(S1))
					return false;
				result.ID = S1.element[S1.top].ID;
				strcpy(result.name, S1.element[S1.top].name);
				S1.top--;
			}

			//输出
			void Display1(Stack1& S1)
			{
				if (IsEmpty1(S1))
					cout << "顺序栈为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					for (int i = 0; i <= S1.top; i++)
					{
						cout << S1.element[i].ID << "                    " << S1.element[i].name << endl;
					}
					cout << "***************************" << endl;
				}
			}



			/*2.链式栈*/
			//定义结点
			typedef struct StackNode
			{
				ElementType data;
				StackNode* link;
			}StackNode;

			//定义链式栈
			typedef struct
			{
				int length;
				StackNode* top;
			}Stack2;

			//创建链式栈
			Stack2* Create2(Stack2* S2)
			{
				S2 = new Stack2;
				S2->top = NULL;
				S2->length = 0;
				return S2;
			}

			//判断栈空
			bool IsEmpty2(Stack2* S2)
			{
				if (S2->top == NULL)
					return true;
				return false;
			}

			//入栈
			bool Push2(Stack2* S2, ElementType& x)
			{
				StackNode* p = new StackNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty2(S2))
				{
					S2->top = p;
					p->link = NULL;
				}
				else
				{
					S2->top = p;
					p->link = S2->top;
				}
				S2->length++;
			}

			//出栈
			bool Pop2(Stack2* S2, ElementType& result)
			{
				if (IsEmpty2(S2))
					return false;
				else
				{
					StackNode* p = S2->top;
					result.ID = p->data.ID;
					strcpy(result.name, p->data.name);
					S2->top = p->link;
					delete p;
					return true;
				}
			}

			//输出
			void Display2(Stack2* S2)
			{
				if (IsEmpty2(S2))
					cout << "链式栈为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					StackNode* p = S2->top;
					while (p)
					{
						cout << p->data.ID << "                    " << p->data.name << endl;
						p = p->link;
					}
					cout << "***************************" << endl;
				}
			}



			/*3.顺序队*/
			//定义顺序队列
			typedef struct
			{
				ElementType* element;
				int MaxSize;
				int front;
				int last;
			}Team1;

			//创建顺序队列
			Team1 Create3(Team1& T, int MaxSize)                    //MaxSize指可以存储数据的个数,在目前队列中,element[0]会空置,1~MaxSize会存储
			{
				T.element = new ElementType[MaxSize];
				T.MaxSize = MaxSize;
				T.front = 0;
				T.last = 0;
			}

			//判断队空
			bool IsEmpty3(Team1& T)
			{
				if (T.front == T.last)
					return true;
				return false;
			}

			//判断队满
			bool IsFull3(Team1& T)
			{
				if (T.front == (T.last + 1) % (T.MaxSize + 1))
					return true;
				return false;
			}

			//入队
			bool In1(Team1& T1, ElementType& x)
			{
				if (IsFull3(T1))
					return false;
				else
				{
					T1.last = (T1.last + 1) % (T1.MaxSize + 1);           //考虑队列的循环利用性
					T1.element[T1.last].ID = x.ID;
					strcpy(T1.element[T1.last].name, x.name);
					return true;
				}
			}

			//出队
			bool Out1(Team1& T1, ElementType& result)
			{
				if (IsEmpty3(T1))
					return false;
				else
				{
					T1.front = (T1.front + 1) % (T1.MaxSize + 1);
					result.ID = T1.element[T1.front].ID;
					strcpy(result.name, T1.element[T1.front].name);
					return true;
				}
			}

			//输出
			void Display3(Team1& T1)
			{
				if (IsEmpty3(T1))
					cout << "顺序队列为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					for (int i = (T1.front + 1) % (T1.MaxSize + 1); i%(T1.MaxSize+1)!= T1.last; i++)
					{
						cout << T1.element[i].ID << "                    " << T1.element[i].name << endl;
					}
					cout << "***************************" << endl;
				}
			}



			/*链式队列*/
			//






137.			#include <bits/stdc++.h>
			using namespace std;

			/*学生数据*/
			typedef struct
			{
				int ID;
				char name[10];
			}student;
			typedef student ElementType;

			/*开始定义不同结构操作*/


			/*1.顺序栈*/
			//定义顺序栈
			typedef struct
			{
				ElementType* element;
				int MaxSize;
				int top;
			}Stack1;

			//创建顺序栈
			Stack1 Create1(Stack1& S1, int MaxSize)
			{	
				S1.MaxSize = MaxSize;
				S1.element = new ElementType[S1.MaxSize];
				S1.top = -1;
				return S1;
			}

			//判断栈空
			bool IsEmpty1(Stack1& S1)
			{
				if (S1.top == -1)
					return true;
				return false;
			}

			//判断栈满
			bool IsFull1(Stack1& S1)
			{
				if (S1.top == S1.MaxSize - 1)
					return true;
				return false;
			}

			//入栈
			bool Push1(Stack1& S1, ElementType& x)
			{
				if (IsFull1(S1))
					return false;
				S1.top++;
				S1.element[S1.top].ID = x.ID;
				strcpy(S1.element[S1.top].name, x.name);
			}

			//出栈
			bool Pop1(Stack1& S1, ElementType& result)
			{
				if (IsEmpty1(S1))
					return false;
				result.ID = S1.element[S1.top].ID;
				strcpy(result.name, S1.element[S1.top].name);
				S1.top--;
			}

			//输入
			void Cin1(Stack1& S1)
			{
				int k;
				cout << "请输入当前学生数量:" << endl;
				cin >> k;
				ElementType newvalue;
				cout << endl << "请输入学生数据:" << endl;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					Push1(S1, newvalue);
					cout << endl;
				}
			}

			//输出
			void Display1(Stack1& S1)
			{
				if (IsEmpty1(S1))
					cout << "顺序栈为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					for (int i = 0; i <= S1.top; i++)
					{
						cout << S1.element[i].ID << "                    " << S1.element[i].name << endl;
					}
					cout << "***************************" << endl;
				}
			}



			/*2.链式栈*/
			//定义结点
			typedef struct StackNode
			{
				ElementType data;
				StackNode* link;
			}StackNode;

			//定义链式栈
			typedef struct
			{
				int length;
				StackNode* top;
			}Stack2;

			//创建链式栈
			Stack2* Create2(Stack2* S2)
			{
				S2 = new Stack2;
				S2->top = NULL;
				S2->length = 0;
				return S2;
			}

			//判断栈空
			bool IsEmpty2(Stack2* S2)
			{
				if (S2->top == NULL)
					return true;
				return false;
			}

			//入栈
			bool Push2(Stack2* S2, ElementType& x)
			{
				StackNode* p = new StackNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty2(S2))
				{
					S2->top = p;
					p->link = NULL;
				}
				else
				{
					p->link = S2->top;
					S2->top = p;
				}
				S2->length++;
			}

			//出栈
			bool Pop2(Stack2* S2, ElementType& result)
			{
				if (IsEmpty2(S2))
					return false;
				else
				{
					StackNode* p = S2->top;
					result.ID = p->data.ID;
					strcpy(result.name, p->data.name);
					S2->top = p->link;
					delete p;
					S2->length--;
					return true;
				}

			}

			//输入
			void Cin2(Stack2* S2)
			{
				int k;
				cout << "请输入当前学生数量:" << endl;
				cin >> k;
				ElementType newvalue;
				cout << endl << "请输入学生数据:" << endl;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					Push2(S2, newvalue);
					cout << endl;
				}
			}

			//输出
			void Display2(Stack2* S2)
			{
				if (IsEmpty2(S2))
					cout << "链式栈为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					StackNode* p = S2->top;
					while (p)
					{
						cout << p->data.ID << "                    " << p->data.name << endl;
						p = p->link;
					}
					cout << "***************************" << endl;
				}
			}



			/*3.顺序队*/
			//定义顺序队列
			typedef struct
			{
				ElementType* element;
				int MaxSize;
				int front;
				int last;
			}Team1;

			//创建顺序队列
			Team1 Create3(Team1& T1, int MaxSize)                    //MaxSize指可以存储数据的个数,在目前队列中,element[0]会空置,1~MaxSize会存储
			{
				T1.element = new ElementType[MaxSize];
				T1.MaxSize = MaxSize;
				T1.front = 0;
				T1.last = 0;
				return T1;
			}

			//判断队空
			bool IsEmpty3(Team1& T1)
			{
				if (T1.front == T1.last)
					return true;
				return false;
			}

			//判断队满
			bool IsFull3(Team1& T1)
			{
				if (T1.front == (T1.last + 1) % (T1.MaxSize + 1))
					return true;
				return false;
			}

			//入队
			bool In1(Team1& T1, ElementType& x)
			{
				if (IsFull3(T1))
					return false;
				else
				{
					T1.last = (T1.last + 1) % (T1.MaxSize + 1);           //考虑队列的循环利用性
					T1.element[T1.last].ID = x.ID;
					strcpy(T1.element[T1.last].name, x.name);
					return true;
				}
			}

			//出队
			bool Out1(Team1& T1, ElementType& result)
			{
				if (IsEmpty3(T1))
					return false;
				else
				{
					T1.front = (T1.front + 1) % (T1.MaxSize + 1);
					result.ID = T1.element[T1.front].ID;
					strcpy(result.name, T1.element[T1.front].name);
					return true;
				}
			}

			//输入
			void Cin3(Team1& T1)
			{
				int k;
				cout << "请输入当前学生数量:" << endl;
				cin >> k;
				ElementType newvalue;
				cout << endl << "请输入学生数据:" << endl;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					In1(T1, newvalue);
					cout << endl;
				}
			}

			//输出
			void Display3(Team1& T1)
			{
				if (IsEmpty3(T1))
					cout << "顺序队列为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					for (int i = (T1.front) % (T1.MaxSize + 1); i%(T1.MaxSize+1)!= T1.last; i++)
					{
						cout << T1.element[i].ID << "                    " << T1.element[i].name << endl;
					}
					cout << "***************************" << endl;
				}
			}



			/*链式队列*/
			//定义队列结点
			typedef struct TeamNode
			{
				ElementType data;
				TeamNode* link;
			}TeamNode;

			//定义链式队列
			typedef struct
			{
				int length;
				TeamNode* front;
				TeamNode* last;
			}Team2;

			//创建链式队列
			Team2* Create4(Team2* T2)
			{
				T2 = new Team2;
				T2->length = 0;
				T2->front = NULL;
				T2->last = NULL;
				return T2;
			}

			//判断队空
			bool IsEmpty4(Team2* T2)
			{
				if (T2->front == NULL)
					return true;
				return false;
			}

			//入队
			bool In2(Team2* T2, ElementType& x)
			{
				TeamNode* p = new TeamNode;
				p->data.ID = x.ID;
				strcpy(p->data.name, x.name);
				if (IsEmpty4(T2))
				{
					T2->last = p;
					T2->front = p;
					p->link = NULL;
				}
				else
				{
					TeamNode* q = T2->last;
					q->link = p;
					T2->last = p;
					p->link = NULL;
				}
				T2->length++;
				return true;
			}

			//出队
			bool Out2(Team2* T2, ElementType& result)
			{
				if (IsEmpty4(T2))
					return false;
				TeamNode* p = T2->front;
				result.ID = p->data.ID;
				strcpy(result.name, p->data.name);
				T2->front = p->link;
				delete p;
				T2->length--;
				return true;
			}

			//输入
			void Cin4(Team2* T2)
			{
				int k;
				cout << "请输入当前学生数量:" << endl;
				cin >> k;
				ElementType newvalue;
				cout << endl << "请输入学生数据:" << endl;
				for (int i = 0; i < k; i++)
				{
					cout << "第" << i + 1 << "名学生:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					In2(T2, newvalue);
					cout << endl;
				}
			}

			//输出
			void Display4(Team2* T2)
			{
				if (IsEmpty4(T2))
					cout << "链式队列为空!" << endl;
				else
				{
					cout << "**********学生数据**********" << endl;
					cout << "学号                    姓名" << endl;
					TeamNode* p = T2->front;
					while (p)
					{
						cout << p->data.ID << "                    " << p->data.name << endl;
						p = p->link;
					}
					cout << "***************************" << endl;
				}
			}



			/*综合操作*/
			//定义栈和队
			Stack1 S1;
			Stack2* S2;
			Team1 T1;
			Team2* T2;

			//菜单1
			void Menu1()
			{
				cout << "选择菜单如下:" << endl;
				cout << "1.顺序堆栈" << endl;
				cout << "2.链式堆栈" << endl;
				cout << "3.顺序队列" << endl;
				cout << "4.链式队列" << endl;
				cout << "5.退出" << endl << endl;
				cout << "请输入选择:" << endl;
			}

			//菜单2
			void Menu2()
			{
				cout << "功能菜单如下:" << endl;
				cout << "1.显示学生信息" << endl;
				cout << "2.插入学生数据" << endl;
				cout << "3.删除学生数据" << endl;
				cout << "4.退出" << endl << endl;
				cout << "请输入选择:" << endl;
			}

			//总创建函数
			void Create(int choice)
			{
				switch (choice)
				{
				case 1:
					int Max1;
					cout << "请输入最大学生数:" << endl;
					cin >> Max1;
					S1 = Create1(S1, Max1);
					break;
				case 2:
					S2 = Create2(S2);
					break;
				case 3:
					int Max2;
					cout << "请输入最大学生数:" << endl;
					cin >> Max2;
					T1 = Create3(T1, Max2);
					break;
				case 4:
					T2 = Create4(T2);
					break;
				}
			}

			//总输入函数
			void Cin(int choice)
			{
				switch (choice)
				{
				case 1:
					Cin1(S1);
					break;
				case 2:
					Cin2(S2);
					break;
				case 3:
					Cin3(T1);
					break;
				case 4:
					Cin4(T2);
					break;
				}
			}

			//总判空函数
			bool IsEmpty(int choice)
			{
				switch (choice)
				{
				case 1:
					return IsEmpty1(S1);
				case 2:
					return IsEmpty2(S2);
				case 3:
					return IsEmpty3(T1);
				case 4:
					return IsEmpty4(T2);
				}
			}

			//总判满函数
			bool IsFull(int choice)
			{
				switch (choice)
				{
				case 1:
					return IsFull1(S1);
				case 2:
					return false;
				case 3:
					return IsFull3(T1);
				case 4:
					return false;
				}
			}

			//总插入函数
			bool In(int choice, ElementType& x)                                //这里的choice是菜单1的选择
			{
				switch (choice)
				{
				case 1:
					Push1(S1, x);
					break;
				case 2:
					Push2(S2, x);
					break;
				case 3:
					In1(T1, x);
					break;
				case 4:
					In2(T2, x);
					break;
				}
			}

			//总删除函数
			bool Out(int choice, ElementType& result)
			{
				switch (choice)
				{
				case 1:
					Pop1(S1, result);
					break;
				case 2:
					Pop2(S2, result);
					break;
				case 3:
					Out1(T1, result);
					break;
				case 4:
					Out2(T2, result);
					break;
				}
			}

			//总输出函数
			bool Display(int choice)
			{
				switch (choice)
				{
				case 1:
					Display1(S1);
					break;
				case 2:
					Display2(S2);
					break;
				case 3:
					Display3(T1);
					break;
				case 4:
					Display4(T2);
					break;
				}
			}

			//主函数
			int main()
			{
				int k1 = 0, k2 = 0;
				ElementType x, result;
				while (1)
				{
					Menu1();
					cin >> k1;
					system("cls");
					if (k1 == 5)
						return 0;
					Create(k1);
					Cin(k1);
					system("cls");
					while (k2 != 4)
					{
						Menu2();
						cin >> k2;
						system("cls");
						switch (k2)
						{
						case 1:
							Display(k1);
							break;
						case 2:
							if (IsFull(k1))
								cout << "满!" << endl;
							else
							{
								cout << "请输入插入数据:" << endl;
								cout << "学号:";
								cin >> x.ID;
								cout << "姓名:";
								cin >> x.name;
								In(k1, x);
								cout << endl << "插入后结果如下:" << endl;
								Display(k1);
							}
							break;
						case 3:
							if (IsEmpty(k1))
								cout << "空!" << endl;
							else
							{
								Out(k1, result);
								cout << "删除的数据如下:" << endl;
								cout << "学号:" << result.ID << "           " << "姓名:" << result.name << endl;
								cout << endl << "删除后结果如下:" << endl;
								Display(k1);
							}
							break;
						}
						system("pause");
						system("cls");
					}
					k2 = 0;
				}
			}






139.			#pragma once
			#include "AppData.h";
			#include <bits/stdc++.h>
			using namespace std;

			typedef struct BinaryTreeNode
			{
				ElementType data;
				BinaryTreeNode* left;
				BinaryTreeNode* right;
			}BinaryTreeNode;

			template<class ElementType>
			class BinaryTree
			{
			public:
				BinaryTree() { TreeRoot = NULL };
				~BinaryTree() {};
				bool IsEmpty();

				//遍历算法,递归
				void PreOrder1(BinaryTree* TreeRoot);
				void InOrder1(BinaryTree* TreeRoot);
				void PostOrder1(BinaryTree* TreeRoot);

				//遍历算法,非递归
				void PreOrder2(BinaryTree* TreeRoot);
				void InOrder2(BinaryTree* TreeRoot);
				void PostOrder2(BinaryTree* TreeRoot);

				//层次遍历
				void LevelOrder_LtoR_UtoD(BinaryTreeNode* TreeRoot);    //从左到右，从上到下
				void LevelOrder_RtoL_DtoU(BinaryTreeNode* TreeRoot);    //从右到左，从下到上

				void MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right);
				BinaryTreeNode* MakeNode(ElementType& x);
				BinaryTreeNode* DeleteTree(BinaryTreeNode* TreeRoot);
				int Node(BinaryTreeNode* TreeRoot, int& count);
				int High(BinaryTreeNode* TreeRoot);
				void Display(BinaryTree* BT);
			private:
				BinaryTreeNode* TreeRoot;
			};

			//创建结点
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::MakeNode(ElementType& x)
			{
				BinaryTreeNode* p = new BinaryTreeNode;
				p->data = x;
				p->left = NULL;
				p->right = NULL;
				return p;
			}

			//构造子树
			template<class ElementType>
			void BinaryTree<ElementType>::MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right)
			{
				Root->left = left;
				Root->right = right;
			}

			//计算高度
			template<class ElementType>
			int BinaryTree<ElementType>::High(BinaryTreeNode* TreeRoot)
			{
				if (!TreeNode)
					return 0;
				else
				{
					int High1 = High(TreeRoot->left);
					int High2 = High(TreeRoot->right);
					if (High1 > High2)
						return ++High1;
					else
						return ++High2;
				}
			}

			//计算结点
			template<class ElementType>
			int BinaryTree<ElementType>::Node(BinaryTreeNode* TreeRoot, int& counts)
			{
				if (TreeRoot)
				{
					count++;
					Node(TreeRoot->left, counts);
					Node(TreeRoot->right, counts);
				}
			}

			//删除二叉树
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::DeleteTree(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					DeleteTree(TreeRoot->left);
					DeleteTree(TreeRoot->left);
					delete TreeRoot;
				}
				TreeRoot = NULL;
				return TreeRoot;
			}





140.			#pragma once
			#include "AppData.h";
			#include <bits/stdc++.h>
			using namespace std;

			typedef struct BinaryTreeNode
			{
				ElementType data;
				BinaryTreeNode* left;
				BinaryTreeNode* right;
			}BinaryTreeNode;

			template<class ElementType>
			class BinaryTree
			{
			public:
				BinaryTree() { TreeRoot = NULL };
				~BinaryTree() {};
				bool IsEmpty();

				//遍历算法,递归
				void PreOrder1(BinaryTreeNode* TreeRoot);
				void InOrder1(BinaryTreeNode* TreeRoot);
				void PostOrder1(BinaryTreeNode* TreeRoot);

				//遍历算法,非递归
				void PreOrder2(BinaryTreeNode* TreeRoot);
				void InOrder2(BinaryTreeNode* TreeRoot);
				void PostOrder2(BinaryTreeNode* TreeRoot);

				//层次遍历
				void LevelOrder_LtoR_UtoD(BinaryTreeNode* TreeRoot);    //从左到右，从上到下
				void LevelOrder_RtoL_DtoU(BinaryTreeNode* TreeRoot);    //从右到左，从下到上

				void MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right);
				BinaryTreeNode* MakeNode(ElementType& x);
				BinaryTreeNode* DeleteTree(BinaryTreeNode* TreeRoot);
				int Node(BinaryTreeNode* TreeRoot, int& count);
				int High(BinaryTreeNode* TreeRoot);
				void DisplayNode(BinaryTreeNode* TreeRoot);
			private:
				BinaryTreeNode* TreeRoot;
			};

			//创建结点
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::MakeNode(ElementType& x)
			{
				BinaryTreeNode* p = new BinaryTreeNode;
				p->data = x;
				p->left = NULL;
				p->right = NULL;
				return p;
			}

			//构造子树
			template<class ElementType>
			void BinaryTree<ElementType>::MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right)
			{
				Root->left = left;
				Root->right = right;
			}

			//计算高度
			template<class ElementType>
			int BinaryTree<ElementType>::High(BinaryTreeNode* TreeRoot)
			{
				if (!TreeNode)
					return 0;
				else
				{
					int High1 = High(TreeRoot->left);
					int High2 = High(TreeRoot->right);
					if (High1 > High2)
						return ++High1;
					else
						return ++High2;
				}
			}

			//计算结点
			template<class ElementType>
			int BinaryTree<ElementType>::Node(BinaryTreeNode* TreeRoot, int& counts)
			{
				if (TreeRoot)
				{
					count++;
					Node(TreeRoot->left, counts);
					Node(TreeRoot->right, counts);
				}
			}

			//删除二叉树
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::DeleteTree(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					DeleteTree(TreeRoot->left);
					DeleteTree(TreeRoot->left);
					delete TreeRoot;
				}
				TreeRoot = NULL;
				return TreeRoot;
			}

			//输出结点
			template<class ElementType>
			void BinaryTree<ElementType>::DisplayNode(BinaryTreeNode* TreeRoot)
			{
				cout << "学号:" << TreeRoot->data.ID << "\t姓名:" << TreeRoot->data.name << endl;
			}



			/*遍历算法,递归*/
			//前序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::PreOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					DisplayNode(TreeRoot);
					PreOrder1(TreeRoot->left);
					PreOder1(TreeRoot->right);
				}
			}

			//中序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::InOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					InOrder1(TreeRoot->left);
					DisplayNode(TreeRoot);
					InOrder1(TreeRoot->right);
				}
			}

			//后序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::PostOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					PostOrder1(TreeRoot->left);
					PostOrder1(TreeRoot->right);
					DisplayNode(TreeRoot);
				}
			}



			/*遍历算法,非递归*/





141.			#pragma once
			#include "AppData.h";
			#include <bits/stdc++.h>
			using namespace std;

			typedef struct BinaryTreeNode
			{
				ElementType data;
				BinaryTreeNode* left;
				BinaryTreeNode* right;
			}BinaryTreeNode;

			template<class ElementType>
			class BinaryTree
			{
			public:
				BinaryTree() { TreeRoot = NULL };
				~BinaryTree() {};
				bool IsEmpty();

				//遍历算法,递归
				void PreOrder1(BinaryTreeNode* TreeRoot);
				void InOrder1(BinaryTreeNode* TreeRoot);
				void PostOrder1(BinaryTreeNode* TreeRoot);

				//遍历算法,非递归
				void PreOrder2(BinaryTreeNode* TreeRoot);
				void InOrder2(BinaryTreeNode* TreeRoot);
				void PostOrder2(BinaryTreeNode* TreeRoot);

				//层次遍历
				void LevelOrder_LtoR_UtoD(BinaryTreeNode* TreeRoot);    //从左到右，从上到下
				void LevelOrder_RtoL_DtoU(BinaryTreeNode* TreeRoot);    //从右到左，从下到上

				void MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right);
				BinaryTreeNode* MakeNode(ElementType& x);
				BinaryTreeNode* DeleteTree(BinaryTreeNode* TreeRoot);
				int Node(BinaryTreeNode* TreeRoot, int& count);
				int High(BinaryTreeNode* TreeRoot);
				void DisplayNode(BinaryTreeNode* TreeRoot);
			private:
				BinaryTreeNode* TreeRoot;
			};

			//创建结点
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::MakeNode(ElementType& x)
			{
				BinaryTreeNode* p = new BinaryTreeNode;
				p->data = x;
				p->left = NULL;
				p->right = NULL;
				return p;
			}

			//构造子树
			template<class ElementType>
			void BinaryTree<ElementType>::MakeBinaryTree(BinaryTreeNode* Root, BinaryTreeNode* left, BinaryTreeNode* right)
			{
				Root->left = left;
				Root->right = right;
			}

			//计算高度
			template<class ElementType>
			int BinaryTree<ElementType>::High(BinaryTreeNode* TreeRoot)
			{
				if (!TreeNode)
					return 0;
				else
				{
					int High1 = High(TreeRoot->left);
					int High2 = High(TreeRoot->right);
					if (High1 > High2)
						return ++High1;
					else
						return ++High2;
				}
			}

			//计算结点
			template<class ElementType>
			int BinaryTree<ElementType>::Node(BinaryTreeNode* TreeRoot, int& counts)
			{
				if (TreeRoot)
				{
					count++;
					Node(TreeRoot->left, counts);
					Node(TreeRoot->right, counts);
				}
			}

			//删除二叉树
			template<class ElementType>
			BinaryTreeNode* BinaryTree<ElementType>::DeleteTree(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					DeleteTree(TreeRoot->left);
					DeleteTree(TreeRoot->left);
					delete TreeRoot;
				}
				TreeRoot = NULL;
				return TreeRoot;
			}

			//输出结点
			template<class ElementType>
			void BinaryTree<ElementType>::DisplayNode(BinaryTreeNode* TreeRoot)
			{
				cout << "学号:" << TreeRoot->data.ID << "\t姓名:" << TreeRoot->data.name << endl;
			}



			/*遍历算法,递归*/
			//前序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::PreOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					DisplayNode(TreeRoot);
					PreOrder1(TreeRoot->left);
					PreOder1(TreeRoot->right);
				}
			}

			//中序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::InOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					InOrder1(TreeRoot->left);
					DisplayNode(TreeRoot);
					InOrder1(TreeRoot->right);
				}
			}

			//后序遍历
			template<class ElementType>
			void BinaryTree<ElementType>::PostOrder1(BinaryTreeNode* TreeRoot)
			{
				if (TreeRoot)
				{
					PostOrder1(TreeRoot->left);
					PostOrder1(TreeRoot->right);
					DisplayNode(TreeRoot);
				}
			}



			/*遍历算法,迭代*/
			//建立堆栈
			typedef BinaryTreeNode StackType;

			template<class StackType>
			class Stack
			{
			public:
				Stack(int MadxSize);
				~Stack() { delete[] element; }
				bool GetTop(StackType* result);
				bool IsEmpty() { return top == -1; }
				bool IsFull() { return top >= MaxSpace; }
				bool Push(StackType* newvalue);
				bool Pop(StackType* result);
				bool Display();
			private:
				int top;
				int MaxSpace;
				StackType* element;
			};

			template<class StackType>
			Stack<StackType>::Stack(int MaxSize)
			{
				MaxSpace = MaxSize;
				element = new StackType[MaxSpace];
				top = -1;
			}

			template<class StackType>
			bool Stack<StackType>::GetTop(StackType* result)
			{
				If(IsEmpty())
					return false;
				result = element[top];
				return true;
			}

			template<class StackType>
			bool Stack<StackType>::Push(StackType* newvalue)
			{
				if (IsFull())
					return false;
				top++;
				element[top] = newvalue;
				return true;
			}

			template<class StackType>
			bool Stack<StackType>::Pop(StackType* result)
			{
				if (IsEmpty())
					return false;
				result = element[top];
				top--;
				return true;
			}

			template<class StackType>
			bool Stack<StackType>::Display()
			{
				StackType x;
				while (!IsEmpty())
				{
					if (!IsEmpty())
					{
						Pop(x);
						cout << "学号:" << x->data.ID << "\t姓名:" << x->data.name << endl;
					}
				}
			}

			//迭代算法(统一迭代法)
			//前序迭代(中左右)
			template<class ElementType>
			void BinaryTree<ElementType>::PreOrder2(BinaryTreeNode* TreeRoot)
			{
				int Max = 20;
				Stack<StackType> S(Max);
				Stack<StackType> Result(Max);
				if(TreeRoot!=NULL)
					S.Push(TreeRoot);
				while (!S.IsEmpty())
				{
					StackType* node = new StackType;
					S.GetTop(node);
					if (node != NULL)
					{
						S.Pop(node);                              //弹出防止栈中重复出现"中"                  
						S.Push(node);
						S.Push(NULL);
						if (node->right != NULL)
							S.Push(node->right);
						if (node->left != NULL)
							S.Push(node->left);
					}
					else
					{
						S.Pop();
						S.GetTop(node);
						Result.Push(node);                        //将结果存入Result中
					}
				}
			}

			//中序遍历(左中右)
			template<class ElementType>
			void BinaryTree<ElementType>::InOrder2(BinaryTreeNode* TreeRoot)
			{
				int Max = 20;
				Stack<StackType> S(Max);
				Stack<StackType> Result(Max);
				if (TreeRoot != NULL)
					S.Push(TreeRoot);
				while (!S.IsEmpty())
				{
					StackType* node = new StackType;
					S.GetTop(node);
					if (node != NULL)
					{
						S.Pop(node);
						if (node->right != NULL)
							S.Push(node->right);
						S.Push(node);
						S.Push(NULL);
						if (node->left != NULL)
							S.Push(node->left);
					}
					else
					{
						S.Pop();
						S.GetTop(node);
						Result.Push(node);
					}
				}
			}

			//后序遍历(左右中)
			template<class ElementType>
			void BinaryTree<ElementType>::InOrder2(BinaryTreeNode* TreeRoot)
			{
				int Max = 20;
				Stack<StackType> S(Max);
				Stack<StackType> Result(Max);
				if (TreeRoot != NULL)
					S.Push(TreeRoot);
				while (!S.IsEmpty())
				{
					StackType* node = new StackType;
					S.GetTop(node);
					if (node != NULL)
					{
						S.Pop(node);
						S.Push(node);
						S.Push(NULL);
						if (node->right != NULL)
							S.Push(node->right);
						if (node->left != NULL)
							S.Push(node->left);
					}
					else
					{
						S.Pop();
						S.GetTop(node);
						Result.Push(node);
					}
				}
			}


			/*层次遍历*/
			//建立队列
			typedef BinaryTreeNode TeamType;

			template<class TeamType>
			class Team
			{
			public:
				Team(int MaxSize);
				~Team() { delete[] element; }
				bool IsEmpty() { return front == end; }
				bool IsFull() { return front == (end + 1) % (MaxSpace + 1); }
				bool GetFront(TeamType& result);
				bool GetEnd(TeamType& result);
				bool Push(TeamType& result);
				bool Pop(TeamType& result);
			private:
				TeamType* element;
				int front;
				int end;
				int MaxSpace;
			};

			template<class TeamType>
			Team<TeamType>::Team(int MaxSize)
			{
				MaxSpace = MaxSize;
				element = new TeamType[MaxSpace + 1];
				front = 0;
				end = 0;
			}

			template<class TeamType>
			bool Team<TeamType>::GetFront(TeamType& result)
			{
				if (IsEmpty())
					return false;
				result = element[(front + 1) % (MaxSpace + 1)];
				return true;
			}

			template<class TeamType>
			bool Team<TeamType>::GetEnd(TeamType& result)
			{
				if (IsEmpty())
					return false;
				result = element[end];
				return true;
			}

			template<class TeamType>
			bool Team<TeamType>::Push(TeamType& newvalue)
			{
				if (IsFull())
					return false;
				end = (end + 1) % (MaxSpace + 1);
				element[end] = newvalue;
				return true;
			}

			template<class TeamType>
			bool Team<TeamType>::Pop(TeamType& result)
			{
				if (IsEmpty())
					return false;
				front = (front + 1) % (MaxSpace + 1);
				result = element[front];
				return true;
			}




142.			#include<bits/stdc++.h>
			using namespace std;
			#define ElemType long

			/*******************************************************************************
				冒泡排序
			*******************************************************************************/
			long Bubblesort(long R[], long n)
			{
				int flag = 1;						
				long BC = 0;
				for (long i = 1; i < n - 1; i++)
				{								
					flag = 0;						
					for (long j = n - 1; j >= i; j--)
					{
						if (R[j] < R[j - 1])			
						{
							long t = R[j];
							R[j] = R[j - 1];
							R[j - 1] = t; flag = 1;
							BC++;

							for (long i = 0; i < n; i++)
								cout << R[i] << " ";
							cout << endl;
						}
					}
				}
				return BC;
			}

			/*******************************************************************************
				快速排序
			*******************************************************************************/
			long quicksort(long R[], long left, long right, long n)
			{
				static long QC = 0;
				long i = left, j = right;
				long temp = R[i];         
				while (i < j)              
				{
					while ((R[j] > temp) && (j > i))   
					{

						j = j - 1;
					}
					if (j > i)
					{
						R[i] = R[j];
						i = i + 1;

					}
					while ((R[i] <= temp) && (j > i))    
					{


						i = i + 1;
					}
					if (i < j)
					{
						R[j] = R[i];
						j = j - 1;

					}


				}
				QC++;
				R[i] = temp;
				for (long k = 0; k < n; k++)
					cout << R[k] << " ";
				cout << endl;
				if (left < i - 1)
					quicksort(R, left, i - 1, n);		
				if (i + 1 < right)
					quicksort(R, i + 1, right, n);		

				return QC;

			}

			void print(ElemType R[], int n)
			{
				for (int i = 0; i <= n - 1; i++)
				{
					if (i % 10 == 0)
					{
						cout << endl;
					}
					cout << R[i] << setw(6);
				}
				cout << endl;

			}



			/*******************************************************************************
				操作选择函数
			*******************************************************************************/
			void operate1(long a[9], long n)
			{
				long R[9];
				long degree;
				char ch;
				cout << "\n**              选择排序算法                      **" << endl;
				cout << "====================================================" << endl;
				cout << "**              1 --- 冒泡排序                    **" << endl;
				cout << "**              2 --- 快速排序                    **" << endl;
				cout << "**              0 --- 退出                    **" << endl;
				cout << "====================================================" << endl;
				cout << "请选择排序算法：\t";
				cin >> ch;
				switch (ch) {
				case '1':
				{
					for (int i = 0; i < n; i++)
					{
						R[i] = a[i];
					}
					degree = Bubblesort(R, n);
					print(R, n);
					operate1(a, n);
					break;
				}

				case '2':

				{
					for (int i = 0; i < n; i++)
					{
						R[i] = a[i];
					}
					degree = quicksort(R, 0, n - 1, n);
					print(R, n);
					operate1(a, n);
					break;
				}
				case '0':
					break;
				}
				system("pause");
				system("cls");
			}

			/*******************************************************************************
				主函数
			*******************************************************************************/
			int main()
			{
				long  num[10] = { 2001,2002,2003,2004,2005,2006,2007,2008,2009 };
				long Chinese[10] = { 88,91,98,87,93,76,53,94,83 };
				long math[10] = { 97,95,99,96,99,70,53,90,65 };
				long English[10] = { 85,92,95,85,96,72,65,88,96 };
				long sum[10] = { 270,278,292,268,288,218,171,272,244 };

				while (1)
				{
					cout << "请输入选择比较的项目:\n";
					cout << "====================================================" << endl;
					cout << "**              1 --- 语文                    **" << endl;
					cout << "**              2 --- 数学                    **" << endl;
					cout << "**              3 --- 英语                    **" << endl;
					cout << "**              4 --- 总分                    **" << endl;
					cout << "**              0 --- 退出                    **" << endl;
					cout << "====================================================" << endl;
					long t[10];
					int choice;
					cin >> choice;
					switch (choice)
					{
					case 1:
						for (int i = 0; i < 10; i++)
							t[i] = Chinese[i];
						break;
					case 2:
						for (int i = 0; i < 10; i++)
							t[i] = math[i];
						break;
					case 3:
						for (int i = 0; i < 10; i++)
							t[i] = English[i];
						break;
					case 4:
						for (int i = 0; i < 10; i++)
							t[i] = sum[i];
						break;
					case 0:
						exit(0);
						break;
					}
					operate1(t, 9);
				}

			}



143.			#include <bits/stdc++.h>
			using namespace std;

			//构造结构
			typedef struct {
				char name[20];
				int ID;
			}ElementType;

			typedef struct {
				ElementType* data;
				int length;
			}List;

			//功能函数
			//1.构造函数
			void Create(List& L, int MaxSize)
			{
				L.data = new ElementType[MaxSize];
				L.length = 0;
			}

			//2.输入函数
			void InPut(List& L, int k)
			{
				for (int i = 0; i < k; i++)
				{
					cout << "请输入第" << i + 1 << "个学生数据:" << endl;
					cout << "学号:";
					cin >> L.data[i].ID;
					cout << "姓名:";
					cin >> L.data[i].name;
					cout << endl;
					L.length++;
				}
			}

			//3.插入函数(k是现实位置,第一到N个)
			bool Insert(List& L, ElementType newvalue, int k, int MaxSize)
			{
				if (L.length >= MaxSize || k <= 0 || k > L.length + 1)
				{
					cout << "插入失败!" << endl;
					return false;
				}
				for (int i = L.length - 1; i >= k - 1; i--)
				{
					L.data[i + 1] = L.data[i];
				}
				L.data[k - 1] = newvalue;
				L.length++;
				return true;
			}

			//4.删除函数
			bool Delete(List& L, int k, ElementType& result)
			{
				if (k <= 0 || k > L.length || L.length <= 0)
				{
					cout << "删除失败!" << endl;
					return false;
				}
				result = L.data[k - 1];
				for (int i = k - 1; i <= L.length - 1; i++)
				{
					L.data[i] = L.data[i + 1];
				}
				L.length--;
				return true;
			}

			//5.查找函数
			bool Search(List L, int k, ElementType& result)
			{
				if (k <= 0 || k > L.length)
				{
					cout << "查找失败!" << endl;
					return false;
				}
				result = L.data[k - 1];
				return true;
			}

			//6.显示函数(小)
			void Display1(ElementType x)
			{
				cout << x.ID << "                    " << x.name << endl;
			}

			//7.显示函数(大)
			void Display2(List L)
			{
				if (L.length == 0)
				{
					cout << "栈空!" << endl;
				}
				else
				{
					cout << "---------------顺序表---------------" << endl;
					cout << "学号                    姓名" << endl;
					for (int i = 0; i < L.length; i++)
					{
						Display1(L.data[i]);
					}
					cout << "-----------------------------------" << endl;
				}
			}

			//8.菜单函数
			void Menu()
			{
				cout << "1---插入数据" << endl;
				cout << "2---删除数据" << endl;
				cout << "3---查找数据" << endl;
				cout << "4---显示数据" << endl;
				cout << "0---退出" << endl;
				cout << "请选择操作:" << endl;
			}

			//实现函数
			int main()
			{
				int MaxSize, k, choice;
				List L;
				cout << "请输入最大空间:" << endl;
				cin >> MaxSize;
				Create(L, MaxSize);
				cout << "请输入当前数据个数:" << endl;
				cin >> k;
				InPut(L, k);
				system("pause");
				system("cls");
				while (1)
				{
					ElementType newvalue, result;
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						if (L.length >= MaxSize)
						{
							cout << "栈满!" << endl;
							break;
						}
						cout << "请输入插入数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						cout << "请输入插入位置:" << endl;
						cin >> k;
						if (Insert(L, newvalue, k, MaxSize))
						{
							cout << "插入后结果如下:" << endl;
							Display2(L);
						}
						break;

					case 2:
						if (L.length <= 0)
						{
							cout << "栈空!" << endl;
							break;
						}
						cout << "请输入删除位置:" << endl;
						cin >> k;
						if (Delete(L, k, result))
						{
							cout << "删除数据如下:" << endl;
							Display1(result);
							cout << "删除后结果如下:" << endl;
							Display2(L);
						}
						break;

					case 3:
						if (L.length <= 0)
						{
							cout << "栈空!" << endl;
							break;
						}
						cout << "请输入查找位置:" << endl;
						cin >> k;
						if (Search(L, k, result))
						{
							cout << "查找结果如下:" << endl;
							Display1(result);
						}
						break;

					case 4:
						if (L.length <= 0)
						{
							cout << "栈空!" << endl;
							break;
						}
						Display2(L);
						break;

					case 0:
						exit(0);
					}
					system("pause");
					system("cls");
				}
				return 0;
			}



144.			#include <bits/stdc++.h>
			using namespace std;

			//定义数据
			typedef struct
			{
				char name[20];
				int ID;
			}ElementType;

			typedef struct Node
			{
				ElementType data;
				Node* next;
			}Node;

			//功能函数
			//1.创建函数
			Node* Create(Node* HeadPtr)
			{
				HeadPtr = new Node;
				HeadPtr->next = NULL;
				return HeadPtr;
			}

			//2.插入函数
			bool Insert(Node* HeadPtr, ElementType newvalue, int k)
			{
				if (k <= 0)
				{
					cout << "位置非法!" << endl;
					return false;
				}
				Node* p = HeadPtr;
				Node* q = new Node;
				while (k - 1 > 0 && p)
				{
					p = p->next;
					k--;
				}
				if (p)
				{
					q->data = newvalue;
					q->next = p->next;
					p->next = q;
					return true;
				}
				else
				{
					cout << "插入失败" << endl;
					return false;
				}
			}

			//3.删除函数
			bool Delete(Node* HeadPtr, ElementType& result, int k)
			{
				if (k <= 0)
				{
					cout << "位置非法!" << endl;
					return false;
				}
				if (!HeadPtr->next)
				{
					cout << "栈空!" << endl;
					return false;
				}
				Node* p = HeadPtr;
				while (k -1> 0 && p)
				{
					p = p->next;
					k--;
				}
				if (p)
				{
					Node* q = p;
					q = p->next;
					p->next = q->next;
					result = q->data;
					delete q;
					return true;
				}
				else
				{
					cout << "删除失败!" << endl;
					return false;
				}
			}

			//4.查找函数
			bool Search(Node* HeadPtr, ElementType& result, int k)
			{
				if (k <= 0)
				{
					cout << "位置非法!" << endl;
					return false;
				}
				if (!HeadPtr->next)
				{
					cout << "栈空!" << endl;
					return false;
				}
				Node* p = HeadPtr;
				while (k > 0 && p)
				{
					p = p->next;
					k--;
				}
				if (p)
				{
					result = p->data;
					return true;
				}
				else
				{
					cout << "查找失败!" << endl;
					return false;
				}
			}

			//5.输入函数
			void InPut(Node* HeadPtr, int n)
			{
				ElementType newvalue;
				for (int i = 0; i < n; i++)
				{
					cout << "请输入第" << i + 1 << "名学生数据:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					cout << endl;
					Insert(HeadPtr, newvalue, 1);
				}
			}

			//6.输出函数(小)
			void Display1(ElementType result)
			{
				cout << result.ID << "                                           " << result.name << endl;
			}

			//7.输出函数(大)
			void Display2(Node* HeadPtr)
			{
				if (!HeadPtr->next)
				{
					cout << "栈空!" << endl;
				}
				else
				{
					Node* p = HeadPtr;
					p = p->next;
					cout << "--------------------------线性表链式--------------------------" << endl;
					cout << "学号                                                      姓名" << endl;
					while (p)
					{
						Display1(p->data);
						p = p->next;
					}
					cout << "-------------------------------------------------------------" << endl;
				}
			}

			//8.菜单函数
			void Menu()
			{
				cout << "1-----插入数据" << endl;
				cout << "2-----删除数据" << endl;
				cout << "3-----查找数据" << endl;
				cout << "4-----显示数据" << endl;
				cout << "0-----退出" << endl;
				cout << "请选择功能:" << endl;
			}


			//实现函数
			int main()
			{
				Node* HeadPtr;
				int n, choice, k;
				ElementType newvalue, result;
				cout << "请输入学生个数:" << endl;
				cin >> n;
				HeadPtr=Create(HeadPtr);
				InPut(HeadPtr, n);
				system("pause");
				system("cls");
				while (1)
				{
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						cout << "请输入插入数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						cout << "请输入插入位置:";
						cin >> k;
						if (Insert(HeadPtr, newvalue, k))
						{
							cout << "插入后结果如下:" << endl;
							Display2(HeadPtr);
						}
						else
						{
							Insert(HeadPtr, newvalue, k);
						}
						break;

					case 2:
						cout << "请输入删除位置:";
						cin >> k;
						if (Delete(HeadPtr, result, k))
						{
							cout << "删除数据如下:" << endl;
							Display1(result);
							cout << "删除后结果如下:" << endl;
							Display2(HeadPtr);
							break;
						}
						else
						{
							Delete(HeadPtr, result, k);
							break;
						}

					case 3:
						cout << "请输入查找位置:";
						cin >> k;
						if (Search(HeadPtr, result, k))
						{
							cout << "查找数据如下:" << endl;
							Display1(result);
							break;
						}
						else
						{
							Search(HeadPtr, result, k);
							break;
						}

					case 4:
						if (!HeadPtr->next)
						{
							cout << "栈空!" << endl;
							break;
						}
						Display2(HeadPtr);
						break;

					case 0:
						exit(0);

					default:
						cout << "选择非法!" << endl;
						break;
					}
					system("pause");
					system("cls");
				}
				return 0;
			}





145.			#include <bits/stdc++.h>
			using namespace std;

			//构建数据
			typedef struct
			{
				int ID;
				char name[20];
			}ElementType;

			typedef struct
			{
				ElementType* data;
				int MaxSize;
				int top;
			}Stack;

			//功能函数
			//1.构建函数
			void Create(Stack& S, int MaxSize)
			{
				S.data = new ElementType[MaxSize];
				S.MaxSize = MaxSize;
				S.top = -1;
			}

			//2.判空函数
			bool IsEmpty(Stack& S)
			{
				if (S.top == -1)
					return true;
				return false;
			}

			//3.判满函数
			bool IsFull(Stack& S)
			{
				if (S.top + 1 == S.MaxSize)
					return true;
				return false;
			}

			//4.压栈函数
			bool Push(Stack& S, ElementType newvalue)
			{
				if (IsFull(S))
					return false;
				S.top++;
				S.data[S.top] = newvalue;
				return true;
			}

			//5.退栈函数
			bool Pop(Stack& S, ElementType& result)
			{
				if (IsEmpty(S))
					return false;
				result = S.data[S.top];
				S.top--;
				return true;
			}

			//6.输入函数
			void Input(Stack& S, int n)
			{
				ElementType newvalue;
				for (int i = 0; i < n; i++)
				{
					cout << "请输入第" << i + 1 << "名学生数据:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					Push(S, newvalue);
				}
			}

			//7.输出函数(小)
			void Display1(ElementType result)
			{
				cout << result.ID << "                                           " << result.name << endl;
			}

			//8.输出函数(大)
			void Display2(Stack S)
			{
				cout << "-------------------------顺序栈----------------------" << endl;
				cout << "学号                                             姓名" << endl;
				for (int i = 0; i <= S.top; i++)
				{
					Display1(S.data[i]);
				}
				cout << "----------------------------------------------------" << endl;
			}

			//9.菜单函数
			void Menu()
			{
				cout << "1-----入栈" << endl;
				cout << "2-----出栈" << endl;
				cout << "3-----显示" << endl;
				cout << "0-----退出" << endl;
				cout << "请选择功能:" << endl;
			}


			//实现函数
			int main()
			{
				Stack S;
				int n, MaxSize, choice;
				ElementType newvalue, result;
				cout << "请输入最大学生数:" << endl;
				cin >> MaxSize;
				Create(S, MaxSize);
				cout << "请输入当前学生数:" << endl;
				cin >> n;
				Input(S, n);
				system("pause");
				system("cls");

				while (1)
				{
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						cout << "请输入插入数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						if (Push(S, newvalue))
						{
							cout << "插入后结果如下:" << endl;
							Display2(S);
						}
						else
						{
							cout << "栈满!" << endl;
						}
						break;

					case 2:
						if (Pop(S, result))
						{
							cout << "弹出数据如下:" << endl;
							Display1(result);
							cout << "弹出后结果如下:" << endl;
							Display2(S);
						}
						else
						{
							cout << "栈空!" << endl;
						}
						break;

					case 3:
						if (IsEmpty(S))
						{
							cout << "栈空!" << endl;
						}
						else
						{
							Display2(S);
						}
						break;

					case 0:
						exit(0);

					default:
						cout << "选择非法!" << endl;
						break;
					}
					system("pause");
					system("cls");
				}
				return 0;
			}




146.			#include <bits/stdc++.h>
			using namespace std;

			//构建数据
			typedef struct
			{
				int ID;
				char name[20];
			}ElementType;

			typedef struct Node
			{
				ElementType data;
				Node* next;
			}Node, * Stack;


			//功能函数
			//1.构建函数
			Stack Create(Stack &S)
			{
				S = new Node;                   //这里的S无具体意义,只代表栈顶,具体可以在入栈操作中解释
				S = NULL;
				return S;
			}

			//2.判空函数
			bool IsEmpty(Stack &S)
			{
				if (!S)
					return true;
				return false;
			}

			//3.入栈函数
			bool Push(Stack &S, ElementType newvalue)
			{
				Node* p = new Node;
				p->data = newvalue;
				p->next = S;
				S = p;
				return true;
			}

			//4.出栈函数
			bool Pop(Stack &S, ElementType& result)
			{
				if (IsEmpty(S))
					return false;
				result = S->data;
				Node* p = S;
				S = p->next;
				delete p;
				return true;
			}

			//5.输入函数
			void Input(Stack &S,int n)
			{
				ElementType newvalue;
				for (int i = 0; i < n; i++)
				{
					cout << "请输入第" << i + 1 << "名学生数据:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					Push(S, newvalue);
				}
			}

			//6.输出函数(小)
			void Display1(ElementType x)
			{
				cout << x.ID << "                             " << x.name << endl;
			}

			//7.输出函数(大)
			void Display2(Stack S)
			{
				Node* p = S;
				cout << "-------------------------链式栈--------------------------" << endl;
				cout << "学号                                                 姓名" << endl;
				while (p)
				{
					Display1(p->data);
					p = p->next;
				}
				cout << "--------------------------------------------------------" << endl;
			}

			//8.菜单函数
			void Menu()
			{
				cout << "1-----入栈" << endl;
				cout << "2-----出栈" << endl;
				cout << "3-----显示" << endl;
				cout << "0-----退出" << endl;
				cout << "请选择功能:" << endl;
			}


			//实现函数
			int main()
			{
				int n, choice;
				ElementType newvalue, result;
				Stack S;
				S = Create(S);
				cout << "请输入当前学生个数:" << endl;
				cin >> n;
				Input(S, n);
				system("pause");
				system("cls");

				while (1)
				{
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						cout << "请输入学生数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						Push(S, newvalue);
						cout << "入栈后结果如下:" << endl;
						Display2(S);
						break;

					case 2:
						if (Pop(S, result))
						{
							cout << "出栈数据如下:" << endl;
							Display1(result);
							cout << "出栈后结果如下:" << endl;
							Display2(S);
						}
						else
						{
							cout << "栈空!" << endl;
						}
						break;

					case 3:
						if (IsEmpty(S))
						{
							cout << "栈空!" << endl;
						}
						else
						{
							Display2(S);
						}
						break;

					case 0:
						exit(0);

					default:
						cout << "选择非法!" << endl;
						break;
					}
					system("pause");
					system("cls");
				}
				return 0;
			}





147.			#include <bits/stdc++.h>
			using namespace std;

			//构建数据
			typedef struct
			{
				int ID;
				char name[20];
			}ElementType;

			typedef struct
			{
				ElementType* data;
				int MaxSize;
				int front;
				int end;
			}Team;


			//功能函数
			//1.构建函数
			void Create(Team& T, int MaxSize)
			{
				T.data = new ElementType[MaxSize + 1];
				T.MaxSize = MaxSize;
				T.front = 0;
				T.end = 0;
			}

			//2.判空函数
			bool IsEmpty(Team T)
			{
				if (T.front == T.end)
					return true;
				return false;
			}

			//3.判满函数
			bool IsFull(Team T)
			{
				if ((T.end + 1) % (T.MaxSize + 1) == T.front)
					return true;
				return false;
			}

			//4.入队函数
			bool In(Team& T, ElementType newvalue)
			{
				if (IsFull(T))
					return false;
				T.end = (T.end + 1) % (T.MaxSize + 1);
				T.data[T.end] = newvalue;
				return true;
			}

			//5.出队函数
			bool Out(Team& T, ElementType& result)
			{
				if (IsEmpty(T))
					return false;
				T.front = (T.front + 1) % (T.MaxSize + 1);
				result = T.data[T.front];
				return true;
			}

			//6.输入函数
			void Input(Team& T, int n)
			{
				ElementType newvalue;
				for (int i = 0; i < n; i++)
				{
					cout << "请输入第" << i + 1 << "名学生数据:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					In(T, newvalue);
				}
			}

			//7.输出函数(小)
			void Display1(ElementType x)
			{
				cout << x.ID << "                                                           " << x.name << endl;
			}

			//8.输出函数(大)
			void Display2(Team& T)
			{
				cout << "---------------------------------顺序队------------------------------" << endl;
				cout << "学号                                                             姓名" << endl;
				for (int i = T.front + 1; (i - 1) % (T.MaxSize + 1) != T.end; i++)
				{
					Display1(T.data[i]);
				}
				cout << "--------------------------------------------------------------------" << endl;
			}

			//9.菜单函数
			void Menu()
			{
				cout << "1----入队" << endl;
				cout << "2----出队" << endl;
				cout << "3----显示" << endl;
				cout << "0----退出" << endl;
				cout << "请选择功能:" << endl;
			}


			//实现函数
			int main()
			{
				int n, choice, MaxSize;
				ElementType newvalue, result;
				Team T;
				cout << "请输入最大学生数:" << endl;
				cin >> MaxSize;
				Create(T, MaxSize);
				cout << "请输入当前学生数:" << endl;
				cin >> n;
				Input(T, n);
				system("pause");
				system("cls");

				while (1)
				{
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						cout << "请输入入队数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						if (In(T, newvalue))
						{
							cout << "入队后结果如下:" << endl;
							Display2(T);
						}
						else
						{
							cout << "入队失败!队满!" << endl;
						}
						break;

					case 2:
						if (Out(T, result))
						{
							cout << "出队数据如下:" << endl;
							Display1(result);
							cout << "出队后结果如下:" << endl;
							Display2(T);
						}
						else
						{
							cout << "出队失败!队空!" << endl;
						}
						break;

					case 3:
						if (IsEmpty(T))
						{
							cout << "队空!" << endl;
						}
						else
						{
							Display2(T);
						}
						break;

					case 0:
						exit(0);

					default:
						cout << "选择非法!" << endl;
						break;
					}
					system("pause");
					system("cls");
				}
				return 0;
			}




148.			#include <bits/stdc++.h>
			using namespace std;

			//构建数据
			typedef struct
			{
				int ID;
				char name[20];
			}ElementType;

			typedef struct Node
			{
				ElementType data;
				Node* next;
			}Node;

			typedef struct
			{
				int length;
				Node* front;
				Node* end;
			}Team;

			//功能函数
			//1.构建函数
			Team* Create(Team* T)
			{
				T = new Team;
				T->front = NULL;
				T->end = NULL;
				T->length = 0;
				return T;
			}

			//2.判空函数
			bool IsEmpty(Team* T)
			{
				if (T->length == 0)
					return true;
				return false;
			}

			//3.入队函数
			void In(Team* T, ElementType newvalue)
			{
				Node* p = new Node;
				p->data = newvalue;
				p->next = NULL;
				if (IsEmpty(T))
				{
					T->end = p;
					T->front = p;
				}
				else
				{
					Node* q = T->end;
					q->next = p;
					T->end = p;
				}
				T->length++;
			}

			//4.出队函数
			bool Out(Team* T, ElementType& result)
			{
				if (IsEmpty(T))
					return false;
				Node* p = T->front;
				result = p->data;
				T->front = p->next;
				delete p;
				T->length--;
				return true;
			}

			//5.输入函数
			void Input(Team* T, int n)
			{
				ElementType newvalue;
				for (int i = 0; i < n; i++)
				{
					cout << "请输入第" << i + 1 << "名学生数据:" << endl;
					cout << "学号:";
					cin >> newvalue.ID;
					cout << "姓名:";
					cin >> newvalue.name;
					In(T, newvalue);
				}
			}

			//6.输出函数(小)
			void Display1(ElementType x)
			{
				cout << x.ID << "                                     " << x.name << endl;
			}

			//7.输出函数(大)
			void Display2(Team* T)
			{
				if (IsEmpty(T))
				{
					cout << "队空!" << endl;
				}
				else
				{
					cout << "----------------链式队----------------" << endl;
					cout << "学号                              姓名" << endl;
					Node* p = T->front;
					for (int i = 0; i < T->length; i++)
					{
						Display1(p->data);
						p = p->next;
					}
					cout << "--------------------------------------" << endl;
				}
			}

			//8.菜单函数
			void Menu()
			{
				cout << "1----入队" << endl;
				cout << "2----出队" << endl;
				cout << "3----显示" << endl;
				cout << "0----退出" << endl;
				cout << "请选择功能:" << endl;
			}



			//实现函数
			int main()
			{
				int n, choice;
				ElementType newvalue, result;
				Team* T=new Team;
				T = Create(T);
				cout << "请输入当前学生数:" << endl;
				cin >> n;
				Input(T, n);
				system("pause");
				system("cls");

				while (1)
				{
					Menu();
					cin >> choice;
					switch (choice)
					{
					case 1:
						cout << "请输入入队数据:" << endl;
						cout << "学号:";
						cin >> newvalue.ID;
						cout << "姓名:";
						cin >> newvalue.name;
						In(T, newvalue);
						cout << "入队后结果如下:" << endl;
						Display2(T);
						break;

					case 2:
						if (Out(T,result))
						{
							cout << "出队数据如下:" << endl;
							Display1(result);
							cout << "出队后结果如下:" << endl;
							Display2(T);
						}
						else
						{
							cout << "出队失败!队空!" << endl;
						}
						break;

					case 3:
						Display2(T);
						break;

					case 0:
						exit(0);

					default:
						cout << "选择非法!" << endl;
						break;
					}
					system("pause");
					system("cls");
				}
				return 0;
			}






149.			#include <bits/stdc++.h>
			using namespace std;

			//构建数据
			typedef struct
			{
				int ID;
				char name;
			}ElementType;

			typedef struct Tree
			{
				ElementType data;
				Tree* left;
				Tree* right;
			}Tree;

			typedef struct
			{
				Tree* Root;
				int len;
			}BinaryTree;

			//功能函数
			//1.构建函数
			BinaryTree* Create(BinaryTree* B,ElementType newvalue)
			{
				B->Root = new Tree;
				B->len = 0;
				B->Root->data = newvalue;
				B->Root->left = NULL;
				B->Root->right = NULL;
				return B;
			}

			//2.递归左右子树(前中后序)


			//3.输出函数


			//4.输入函数
			void Display(BinaryTree* B)
			{

			}

			//5.菜单函数

			//实现函数






150.			
